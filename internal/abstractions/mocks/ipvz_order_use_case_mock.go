// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

import (
	"context"
	mm_abstractions "homework/internal/abstractions"
	"homework/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	_ "github.com/gojuno/minimock/v3"
)

// IPVZOrderUseCaseMock implements mm_abstractions.IPVZOrderUseCase
type IPVZOrderUseCaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAcceptOrderDelivery          func(ctx context.Context, orderID string, recipientID string, storageTime time.Duration, cost int, weight int, packaging domain.PackagingType, additionalFilm bool) (err error)
	funcAcceptOrderDeliveryOrigin    string
	inspectFuncAcceptOrderDelivery   func(ctx context.Context, orderID string, recipientID string, storageTime time.Duration, cost int, weight int, packaging domain.PackagingType, additionalFilm bool)
	afterAcceptOrderDeliveryCounter  uint64
	beforeAcceptOrderDeliveryCounter uint64
	AcceptOrderDeliveryMock          mIPVZOrderUseCaseMockAcceptOrderDelivery

	funcAcceptReturn          func(ctx context.Context, userID string, orderID string) (err error)
	funcAcceptReturnOrigin    string
	inspectFuncAcceptReturn   func(ctx context.Context, userID string, orderID string)
	afterAcceptReturnCounter  uint64
	beforeAcceptReturnCounter uint64
	AcceptReturnMock          mIPVZOrderUseCaseMockAcceptReturn

	funcGetOrders          func(ctx context.Context, userID string, options ...mm_abstractions.GetOrdersOptFunc) (pa1 []domain.PVZOrder, err error)
	funcGetOrdersOrigin    string
	inspectFuncGetOrders   func(ctx context.Context, userID string, options ...mm_abstractions.GetOrdersOptFunc)
	afterGetOrdersCounter  uint64
	beforeGetOrdersCounter uint64
	GetOrdersMock          mIPVZOrderUseCaseMockGetOrders

	funcGetReturns          func(ctx context.Context, options ...mm_abstractions.PagePaginationOptFunc) (pa1 []domain.PVZOrder, err error)
	funcGetReturnsOrigin    string
	inspectFuncGetReturns   func(ctx context.Context, options ...mm_abstractions.PagePaginationOptFunc)
	afterGetReturnsCounter  uint64
	beforeGetReturnsCounter uint64
	GetReturnsMock          mIPVZOrderUseCaseMockGetReturns

	funcGiveOrderToClient          func(ctx context.Context, orderIDs []string) (err error)
	funcGiveOrderToClientOrigin    string
	inspectFuncGiveOrderToClient   func(ctx context.Context, orderIDs []string)
	afterGiveOrderToClientCounter  uint64
	beforeGiveOrderToClientCounter uint64
	GiveOrderToClientMock          mIPVZOrderUseCaseMockGiveOrderToClient

	funcReturnOrderDelivery          func(ctx context.Context, orderID string) (err error)
	funcReturnOrderDeliveryOrigin    string
	inspectFuncReturnOrderDelivery   func(ctx context.Context, orderID string)
	afterReturnOrderDeliveryCounter  uint64
	beforeReturnOrderDeliveryCounter uint64
	ReturnOrderDeliveryMock          mIPVZOrderUseCaseMockReturnOrderDelivery
}

// NewIPVZOrderUseCaseMock returns a mock for mm_abstractions.IPVZOrderUseCase
func NewIPVZOrderUseCaseMock(t minimock.Tester) *IPVZOrderUseCaseMock {
	m := &IPVZOrderUseCaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AcceptOrderDeliveryMock = mIPVZOrderUseCaseMockAcceptOrderDelivery{mock: m}
	m.AcceptOrderDeliveryMock.callArgs = []*IPVZOrderUseCaseMockAcceptOrderDeliveryParams{}

	m.AcceptReturnMock = mIPVZOrderUseCaseMockAcceptReturn{mock: m}
	m.AcceptReturnMock.callArgs = []*IPVZOrderUseCaseMockAcceptReturnParams{}

	m.GetOrdersMock = mIPVZOrderUseCaseMockGetOrders{mock: m}
	m.GetOrdersMock.callArgs = []*IPVZOrderUseCaseMockGetOrdersParams{}

	m.GetReturnsMock = mIPVZOrderUseCaseMockGetReturns{mock: m}
	m.GetReturnsMock.callArgs = []*IPVZOrderUseCaseMockGetReturnsParams{}

	m.GiveOrderToClientMock = mIPVZOrderUseCaseMockGiveOrderToClient{mock: m}
	m.GiveOrderToClientMock.callArgs = []*IPVZOrderUseCaseMockGiveOrderToClientParams{}

	m.ReturnOrderDeliveryMock = mIPVZOrderUseCaseMockReturnOrderDelivery{mock: m}
	m.ReturnOrderDeliveryMock.callArgs = []*IPVZOrderUseCaseMockReturnOrderDeliveryParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIPVZOrderUseCaseMockAcceptOrderDelivery struct {
	optional           bool
	mock               *IPVZOrderUseCaseMock
	defaultExpectation *IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation
	expectations       []*IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation

	callArgs []*IPVZOrderUseCaseMockAcceptOrderDeliveryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation specifies expectation struct of the IPVZOrderUseCase.AcceptOrderDelivery
type IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation struct {
	mock               *IPVZOrderUseCaseMock
	params             *IPVZOrderUseCaseMockAcceptOrderDeliveryParams
	paramPtrs          *IPVZOrderUseCaseMockAcceptOrderDeliveryParamPtrs
	expectationOrigins IPVZOrderUseCaseMockAcceptOrderDeliveryExpectationOrigins
	results            *IPVZOrderUseCaseMockAcceptOrderDeliveryResults
	returnOrigin       string
	Counter            uint64
}

// IPVZOrderUseCaseMockAcceptOrderDeliveryParams contains parameters of the IPVZOrderUseCase.AcceptOrderDelivery
type IPVZOrderUseCaseMockAcceptOrderDeliveryParams struct {
	ctx            context.Context
	orderID        string
	recipientID    string
	storageTime    time.Duration
	cost           int
	weight         int
	packaging      domain.PackagingType
	additionalFilm bool
}

// IPVZOrderUseCaseMockAcceptOrderDeliveryParamPtrs contains pointers to parameters of the IPVZOrderUseCase.AcceptOrderDelivery
type IPVZOrderUseCaseMockAcceptOrderDeliveryParamPtrs struct {
	ctx            *context.Context
	orderID        *string
	recipientID    *string
	storageTime    *time.Duration
	cost           *int
	weight         *int
	packaging      *domain.PackagingType
	additionalFilm *bool
}

// IPVZOrderUseCaseMockAcceptOrderDeliveryResults contains results of the IPVZOrderUseCase.AcceptOrderDelivery
type IPVZOrderUseCaseMockAcceptOrderDeliveryResults struct {
	err error
}

// IPVZOrderUseCaseMockAcceptOrderDeliveryOrigins contains origins of expectations of the IPVZOrderUseCase.AcceptOrderDelivery
type IPVZOrderUseCaseMockAcceptOrderDeliveryExpectationOrigins struct {
	origin               string
	originCtx            string
	originOrderID        string
	originRecipientID    string
	originStorageTime    string
	originCost           string
	originWeight         string
	originPackaging      string
	originAdditionalFilm string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) Optional() *mIPVZOrderUseCaseMockAcceptOrderDelivery {
	mmAcceptOrderDelivery.optional = true
	return mmAcceptOrderDelivery
}

// Expect sets up expected params for IPVZOrderUseCase.AcceptOrderDelivery
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) Expect(ctx context.Context, orderID string, recipientID string, storageTime time.Duration, cost int, weight int, packaging domain.PackagingType, additionalFilm bool) *mIPVZOrderUseCaseMockAcceptOrderDelivery {
	if mmAcceptOrderDelivery.mock.funcAcceptOrderDelivery != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Set")
	}

	if mmAcceptOrderDelivery.defaultExpectation == nil {
		mmAcceptOrderDelivery.defaultExpectation = &IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation{}
	}

	if mmAcceptOrderDelivery.defaultExpectation.paramPtrs != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by ExpectParams functions")
	}

	mmAcceptOrderDelivery.defaultExpectation.params = &IPVZOrderUseCaseMockAcceptOrderDeliveryParams{ctx, orderID, recipientID, storageTime, cost, weight, packaging, additionalFilm}
	mmAcceptOrderDelivery.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAcceptOrderDelivery.expectations {
		if minimock.Equal(e.params, mmAcceptOrderDelivery.defaultExpectation.params) {
			mmAcceptOrderDelivery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptOrderDelivery.defaultExpectation.params)
		}
	}

	return mmAcceptOrderDelivery
}

// ExpectCtxParam1 sets up expected param ctx for IPVZOrderUseCase.AcceptOrderDelivery
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) ExpectCtxParam1(ctx context.Context) *mIPVZOrderUseCaseMockAcceptOrderDelivery {
	if mmAcceptOrderDelivery.mock.funcAcceptOrderDelivery != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Set")
	}

	if mmAcceptOrderDelivery.defaultExpectation == nil {
		mmAcceptOrderDelivery.defaultExpectation = &IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation{}
	}

	if mmAcceptOrderDelivery.defaultExpectation.params != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Expect")
	}

	if mmAcceptOrderDelivery.defaultExpectation.paramPtrs == nil {
		mmAcceptOrderDelivery.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockAcceptOrderDeliveryParamPtrs{}
	}
	mmAcceptOrderDelivery.defaultExpectation.paramPtrs.ctx = &ctx
	mmAcceptOrderDelivery.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAcceptOrderDelivery
}

// ExpectOrderIDParam2 sets up expected param orderID for IPVZOrderUseCase.AcceptOrderDelivery
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) ExpectOrderIDParam2(orderID string) *mIPVZOrderUseCaseMockAcceptOrderDelivery {
	if mmAcceptOrderDelivery.mock.funcAcceptOrderDelivery != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Set")
	}

	if mmAcceptOrderDelivery.defaultExpectation == nil {
		mmAcceptOrderDelivery.defaultExpectation = &IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation{}
	}

	if mmAcceptOrderDelivery.defaultExpectation.params != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Expect")
	}

	if mmAcceptOrderDelivery.defaultExpectation.paramPtrs == nil {
		mmAcceptOrderDelivery.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockAcceptOrderDeliveryParamPtrs{}
	}
	mmAcceptOrderDelivery.defaultExpectation.paramPtrs.orderID = &orderID
	mmAcceptOrderDelivery.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmAcceptOrderDelivery
}

// ExpectRecipientIDParam3 sets up expected param recipientID for IPVZOrderUseCase.AcceptOrderDelivery
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) ExpectRecipientIDParam3(recipientID string) *mIPVZOrderUseCaseMockAcceptOrderDelivery {
	if mmAcceptOrderDelivery.mock.funcAcceptOrderDelivery != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Set")
	}

	if mmAcceptOrderDelivery.defaultExpectation == nil {
		mmAcceptOrderDelivery.defaultExpectation = &IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation{}
	}

	if mmAcceptOrderDelivery.defaultExpectation.params != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Expect")
	}

	if mmAcceptOrderDelivery.defaultExpectation.paramPtrs == nil {
		mmAcceptOrderDelivery.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockAcceptOrderDeliveryParamPtrs{}
	}
	mmAcceptOrderDelivery.defaultExpectation.paramPtrs.recipientID = &recipientID
	mmAcceptOrderDelivery.defaultExpectation.expectationOrigins.originRecipientID = minimock.CallerInfo(1)

	return mmAcceptOrderDelivery
}

// ExpectStorageTimeParam4 sets up expected param storageTime for IPVZOrderUseCase.AcceptOrderDelivery
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) ExpectStorageTimeParam4(storageTime time.Duration) *mIPVZOrderUseCaseMockAcceptOrderDelivery {
	if mmAcceptOrderDelivery.mock.funcAcceptOrderDelivery != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Set")
	}

	if mmAcceptOrderDelivery.defaultExpectation == nil {
		mmAcceptOrderDelivery.defaultExpectation = &IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation{}
	}

	if mmAcceptOrderDelivery.defaultExpectation.params != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Expect")
	}

	if mmAcceptOrderDelivery.defaultExpectation.paramPtrs == nil {
		mmAcceptOrderDelivery.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockAcceptOrderDeliveryParamPtrs{}
	}
	mmAcceptOrderDelivery.defaultExpectation.paramPtrs.storageTime = &storageTime
	mmAcceptOrderDelivery.defaultExpectation.expectationOrigins.originStorageTime = minimock.CallerInfo(1)

	return mmAcceptOrderDelivery
}

// ExpectCostParam5 sets up expected param cost for IPVZOrderUseCase.AcceptOrderDelivery
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) ExpectCostParam5(cost int) *mIPVZOrderUseCaseMockAcceptOrderDelivery {
	if mmAcceptOrderDelivery.mock.funcAcceptOrderDelivery != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Set")
	}

	if mmAcceptOrderDelivery.defaultExpectation == nil {
		mmAcceptOrderDelivery.defaultExpectation = &IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation{}
	}

	if mmAcceptOrderDelivery.defaultExpectation.params != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Expect")
	}

	if mmAcceptOrderDelivery.defaultExpectation.paramPtrs == nil {
		mmAcceptOrderDelivery.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockAcceptOrderDeliveryParamPtrs{}
	}
	mmAcceptOrderDelivery.defaultExpectation.paramPtrs.cost = &cost
	mmAcceptOrderDelivery.defaultExpectation.expectationOrigins.originCost = minimock.CallerInfo(1)

	return mmAcceptOrderDelivery
}

// ExpectWeightParam6 sets up expected param weight for IPVZOrderUseCase.AcceptOrderDelivery
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) ExpectWeightParam6(weight int) *mIPVZOrderUseCaseMockAcceptOrderDelivery {
	if mmAcceptOrderDelivery.mock.funcAcceptOrderDelivery != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Set")
	}

	if mmAcceptOrderDelivery.defaultExpectation == nil {
		mmAcceptOrderDelivery.defaultExpectation = &IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation{}
	}

	if mmAcceptOrderDelivery.defaultExpectation.params != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Expect")
	}

	if mmAcceptOrderDelivery.defaultExpectation.paramPtrs == nil {
		mmAcceptOrderDelivery.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockAcceptOrderDeliveryParamPtrs{}
	}
	mmAcceptOrderDelivery.defaultExpectation.paramPtrs.weight = &weight
	mmAcceptOrderDelivery.defaultExpectation.expectationOrigins.originWeight = minimock.CallerInfo(1)

	return mmAcceptOrderDelivery
}

// ExpectPackagingParam7 sets up expected param packaging for IPVZOrderUseCase.AcceptOrderDelivery
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) ExpectPackagingParam7(packaging domain.PackagingType) *mIPVZOrderUseCaseMockAcceptOrderDelivery {
	if mmAcceptOrderDelivery.mock.funcAcceptOrderDelivery != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Set")
	}

	if mmAcceptOrderDelivery.defaultExpectation == nil {
		mmAcceptOrderDelivery.defaultExpectation = &IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation{}
	}

	if mmAcceptOrderDelivery.defaultExpectation.params != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Expect")
	}

	if mmAcceptOrderDelivery.defaultExpectation.paramPtrs == nil {
		mmAcceptOrderDelivery.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockAcceptOrderDeliveryParamPtrs{}
	}
	mmAcceptOrderDelivery.defaultExpectation.paramPtrs.packaging = &packaging
	mmAcceptOrderDelivery.defaultExpectation.expectationOrigins.originPackaging = minimock.CallerInfo(1)

	return mmAcceptOrderDelivery
}

// ExpectAdditionalFilmParam8 sets up expected param additionalFilm for IPVZOrderUseCase.AcceptOrderDelivery
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) ExpectAdditionalFilmParam8(additionalFilm bool) *mIPVZOrderUseCaseMockAcceptOrderDelivery {
	if mmAcceptOrderDelivery.mock.funcAcceptOrderDelivery != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Set")
	}

	if mmAcceptOrderDelivery.defaultExpectation == nil {
		mmAcceptOrderDelivery.defaultExpectation = &IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation{}
	}

	if mmAcceptOrderDelivery.defaultExpectation.params != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Expect")
	}

	if mmAcceptOrderDelivery.defaultExpectation.paramPtrs == nil {
		mmAcceptOrderDelivery.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockAcceptOrderDeliveryParamPtrs{}
	}
	mmAcceptOrderDelivery.defaultExpectation.paramPtrs.additionalFilm = &additionalFilm
	mmAcceptOrderDelivery.defaultExpectation.expectationOrigins.originAdditionalFilm = minimock.CallerInfo(1)

	return mmAcceptOrderDelivery
}

// Inspect accepts an inspector function that has same arguments as the IPVZOrderUseCase.AcceptOrderDelivery
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) Inspect(f func(ctx context.Context, orderID string, recipientID string, storageTime time.Duration, cost int, weight int, packaging domain.PackagingType, additionalFilm bool)) *mIPVZOrderUseCaseMockAcceptOrderDelivery {
	if mmAcceptOrderDelivery.mock.inspectFuncAcceptOrderDelivery != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("Inspect function is already set for IPVZOrderUseCaseMock.AcceptOrderDelivery")
	}

	mmAcceptOrderDelivery.mock.inspectFuncAcceptOrderDelivery = f

	return mmAcceptOrderDelivery
}

// Return sets up results that will be returned by IPVZOrderUseCase.AcceptOrderDelivery
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) Return(err error) *IPVZOrderUseCaseMock {
	if mmAcceptOrderDelivery.mock.funcAcceptOrderDelivery != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Set")
	}

	if mmAcceptOrderDelivery.defaultExpectation == nil {
		mmAcceptOrderDelivery.defaultExpectation = &IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation{mock: mmAcceptOrderDelivery.mock}
	}
	mmAcceptOrderDelivery.defaultExpectation.results = &IPVZOrderUseCaseMockAcceptOrderDeliveryResults{err}
	mmAcceptOrderDelivery.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAcceptOrderDelivery.mock
}

// Set uses given function f to mock the IPVZOrderUseCase.AcceptOrderDelivery method
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) Set(f func(ctx context.Context, orderID string, recipientID string, storageTime time.Duration, cost int, weight int, packaging domain.PackagingType, additionalFilm bool) (err error)) *IPVZOrderUseCaseMock {
	if mmAcceptOrderDelivery.defaultExpectation != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("Default expectation is already set for the IPVZOrderUseCase.AcceptOrderDelivery method")
	}

	if len(mmAcceptOrderDelivery.expectations) > 0 {
		mmAcceptOrderDelivery.mock.t.Fatalf("Some expectations are already set for the IPVZOrderUseCase.AcceptOrderDelivery method")
	}

	mmAcceptOrderDelivery.mock.funcAcceptOrderDelivery = f
	mmAcceptOrderDelivery.mock.funcAcceptOrderDeliveryOrigin = minimock.CallerInfo(1)
	return mmAcceptOrderDelivery.mock
}

// When sets expectation for the IPVZOrderUseCase.AcceptOrderDelivery which will trigger the result defined by the following
// Then helper
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) When(ctx context.Context, orderID string, recipientID string, storageTime time.Duration, cost int, weight int, packaging domain.PackagingType, additionalFilm bool) *IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation {
	if mmAcceptOrderDelivery.mock.funcAcceptOrderDelivery != nil {
		mmAcceptOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptOrderDelivery mock is already set by Set")
	}

	expectation := &IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation{
		mock:               mmAcceptOrderDelivery.mock,
		params:             &IPVZOrderUseCaseMockAcceptOrderDeliveryParams{ctx, orderID, recipientID, storageTime, cost, weight, packaging, additionalFilm},
		expectationOrigins: IPVZOrderUseCaseMockAcceptOrderDeliveryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAcceptOrderDelivery.expectations = append(mmAcceptOrderDelivery.expectations, expectation)
	return expectation
}

// Then sets up IPVZOrderUseCase.AcceptOrderDelivery return parameters for the expectation previously defined by the When method
func (e *IPVZOrderUseCaseMockAcceptOrderDeliveryExpectation) Then(err error) *IPVZOrderUseCaseMock {
	e.results = &IPVZOrderUseCaseMockAcceptOrderDeliveryResults{err}
	return e.mock
}

// Times sets number of times IPVZOrderUseCase.AcceptOrderDelivery should be invoked
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) Times(n uint64) *mIPVZOrderUseCaseMockAcceptOrderDelivery {
	if n == 0 {
		mmAcceptOrderDelivery.mock.t.Fatalf("Times of IPVZOrderUseCaseMock.AcceptOrderDelivery mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcceptOrderDelivery.expectedInvocations, n)
	mmAcceptOrderDelivery.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAcceptOrderDelivery
}

func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) invocationsDone() bool {
	if len(mmAcceptOrderDelivery.expectations) == 0 && mmAcceptOrderDelivery.defaultExpectation == nil && mmAcceptOrderDelivery.mock.funcAcceptOrderDelivery == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAcceptOrderDelivery.mock.afterAcceptOrderDeliveryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcceptOrderDelivery.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AcceptOrderDelivery implements mm_abstractions.IPVZOrderUseCase
func (mmAcceptOrderDelivery *IPVZOrderUseCaseMock) AcceptOrderDelivery(ctx context.Context, orderID string, recipientID string, storageTime time.Duration, cost int, weight int, packaging domain.PackagingType, additionalFilm bool) (err error) {
	mm_atomic.AddUint64(&mmAcceptOrderDelivery.beforeAcceptOrderDeliveryCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptOrderDelivery.afterAcceptOrderDeliveryCounter, 1)

	mmAcceptOrderDelivery.t.Helper()

	if mmAcceptOrderDelivery.inspectFuncAcceptOrderDelivery != nil {
		mmAcceptOrderDelivery.inspectFuncAcceptOrderDelivery(ctx, orderID, recipientID, storageTime, cost, weight, packaging, additionalFilm)
	}

	mm_params := IPVZOrderUseCaseMockAcceptOrderDeliveryParams{ctx, orderID, recipientID, storageTime, cost, weight, packaging, additionalFilm}

	// Record call args
	mmAcceptOrderDelivery.AcceptOrderDeliveryMock.mutex.Lock()
	mmAcceptOrderDelivery.AcceptOrderDeliveryMock.callArgs = append(mmAcceptOrderDelivery.AcceptOrderDeliveryMock.callArgs, &mm_params)
	mmAcceptOrderDelivery.AcceptOrderDeliveryMock.mutex.Unlock()

	for _, e := range mmAcceptOrderDelivery.AcceptOrderDeliveryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAcceptOrderDelivery.AcceptOrderDeliveryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptOrderDelivery.AcceptOrderDeliveryMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptOrderDelivery.AcceptOrderDeliveryMock.defaultExpectation.params
		mm_want_ptrs := mmAcceptOrderDelivery.AcceptOrderDeliveryMock.defaultExpectation.paramPtrs

		mm_got := IPVZOrderUseCaseMockAcceptOrderDeliveryParams{ctx, orderID, recipientID, storageTime, cost, weight, packaging, additionalFilm}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAcceptOrderDelivery.t.Errorf("IPVZOrderUseCaseMock.AcceptOrderDelivery got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptOrderDelivery.AcceptOrderDeliveryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmAcceptOrderDelivery.t.Errorf("IPVZOrderUseCaseMock.AcceptOrderDelivery got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptOrderDelivery.AcceptOrderDeliveryMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.recipientID != nil && !minimock.Equal(*mm_want_ptrs.recipientID, mm_got.recipientID) {
				mmAcceptOrderDelivery.t.Errorf("IPVZOrderUseCaseMock.AcceptOrderDelivery got unexpected parameter recipientID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptOrderDelivery.AcceptOrderDeliveryMock.defaultExpectation.expectationOrigins.originRecipientID, *mm_want_ptrs.recipientID, mm_got.recipientID, minimock.Diff(*mm_want_ptrs.recipientID, mm_got.recipientID))
			}

			if mm_want_ptrs.storageTime != nil && !minimock.Equal(*mm_want_ptrs.storageTime, mm_got.storageTime) {
				mmAcceptOrderDelivery.t.Errorf("IPVZOrderUseCaseMock.AcceptOrderDelivery got unexpected parameter storageTime, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptOrderDelivery.AcceptOrderDeliveryMock.defaultExpectation.expectationOrigins.originStorageTime, *mm_want_ptrs.storageTime, mm_got.storageTime, minimock.Diff(*mm_want_ptrs.storageTime, mm_got.storageTime))
			}

			if mm_want_ptrs.cost != nil && !minimock.Equal(*mm_want_ptrs.cost, mm_got.cost) {
				mmAcceptOrderDelivery.t.Errorf("IPVZOrderUseCaseMock.AcceptOrderDelivery got unexpected parameter cost, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptOrderDelivery.AcceptOrderDeliveryMock.defaultExpectation.expectationOrigins.originCost, *mm_want_ptrs.cost, mm_got.cost, minimock.Diff(*mm_want_ptrs.cost, mm_got.cost))
			}

			if mm_want_ptrs.weight != nil && !minimock.Equal(*mm_want_ptrs.weight, mm_got.weight) {
				mmAcceptOrderDelivery.t.Errorf("IPVZOrderUseCaseMock.AcceptOrderDelivery got unexpected parameter weight, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptOrderDelivery.AcceptOrderDeliveryMock.defaultExpectation.expectationOrigins.originWeight, *mm_want_ptrs.weight, mm_got.weight, minimock.Diff(*mm_want_ptrs.weight, mm_got.weight))
			}

			if mm_want_ptrs.packaging != nil && !minimock.Equal(*mm_want_ptrs.packaging, mm_got.packaging) {
				mmAcceptOrderDelivery.t.Errorf("IPVZOrderUseCaseMock.AcceptOrderDelivery got unexpected parameter packaging, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptOrderDelivery.AcceptOrderDeliveryMock.defaultExpectation.expectationOrigins.originPackaging, *mm_want_ptrs.packaging, mm_got.packaging, minimock.Diff(*mm_want_ptrs.packaging, mm_got.packaging))
			}

			if mm_want_ptrs.additionalFilm != nil && !minimock.Equal(*mm_want_ptrs.additionalFilm, mm_got.additionalFilm) {
				mmAcceptOrderDelivery.t.Errorf("IPVZOrderUseCaseMock.AcceptOrderDelivery got unexpected parameter additionalFilm, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptOrderDelivery.AcceptOrderDeliveryMock.defaultExpectation.expectationOrigins.originAdditionalFilm, *mm_want_ptrs.additionalFilm, mm_got.additionalFilm, minimock.Diff(*mm_want_ptrs.additionalFilm, mm_got.additionalFilm))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptOrderDelivery.t.Errorf("IPVZOrderUseCaseMock.AcceptOrderDelivery got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAcceptOrderDelivery.AcceptOrderDeliveryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcceptOrderDelivery.AcceptOrderDeliveryMock.defaultExpectation.results
		if mm_results == nil {
			mmAcceptOrderDelivery.t.Fatal("No results are set for the IPVZOrderUseCaseMock.AcceptOrderDelivery")
		}
		return (*mm_results).err
	}
	if mmAcceptOrderDelivery.funcAcceptOrderDelivery != nil {
		return mmAcceptOrderDelivery.funcAcceptOrderDelivery(ctx, orderID, recipientID, storageTime, cost, weight, packaging, additionalFilm)
	}
	mmAcceptOrderDelivery.t.Fatalf("Unexpected call to IPVZOrderUseCaseMock.AcceptOrderDelivery. %v %v %v %v %v %v %v %v", ctx, orderID, recipientID, storageTime, cost, weight, packaging, additionalFilm)
	return
}

// AcceptOrderDeliveryAfterCounter returns a count of finished IPVZOrderUseCaseMock.AcceptOrderDelivery invocations
func (mmAcceptOrderDelivery *IPVZOrderUseCaseMock) AcceptOrderDeliveryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptOrderDelivery.afterAcceptOrderDeliveryCounter)
}

// AcceptOrderDeliveryBeforeCounter returns a count of IPVZOrderUseCaseMock.AcceptOrderDelivery invocations
func (mmAcceptOrderDelivery *IPVZOrderUseCaseMock) AcceptOrderDeliveryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptOrderDelivery.beforeAcceptOrderDeliveryCounter)
}

// Calls returns a list of arguments used in each call to IPVZOrderUseCaseMock.AcceptOrderDelivery.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptOrderDelivery *mIPVZOrderUseCaseMockAcceptOrderDelivery) Calls() []*IPVZOrderUseCaseMockAcceptOrderDeliveryParams {
	mmAcceptOrderDelivery.mutex.RLock()

	argCopy := make([]*IPVZOrderUseCaseMockAcceptOrderDeliveryParams, len(mmAcceptOrderDelivery.callArgs))
	copy(argCopy, mmAcceptOrderDelivery.callArgs)

	mmAcceptOrderDelivery.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptOrderDeliveryDone returns true if the count of the AcceptOrderDelivery invocations corresponds
// the number of defined expectations
func (m *IPVZOrderUseCaseMock) MinimockAcceptOrderDeliveryDone() bool {
	if m.AcceptOrderDeliveryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AcceptOrderDeliveryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcceptOrderDeliveryMock.invocationsDone()
}

// MinimockAcceptOrderDeliveryInspect logs each unmet expectation
func (m *IPVZOrderUseCaseMock) MinimockAcceptOrderDeliveryInspect() {
	for _, e := range m.AcceptOrderDeliveryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.AcceptOrderDelivery at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAcceptOrderDeliveryCounter := mm_atomic.LoadUint64(&m.afterAcceptOrderDeliveryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptOrderDeliveryMock.defaultExpectation != nil && afterAcceptOrderDeliveryCounter < 1 {
		if m.AcceptOrderDeliveryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.AcceptOrderDelivery at\n%s", m.AcceptOrderDeliveryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.AcceptOrderDelivery at\n%s with params: %#v", m.AcceptOrderDeliveryMock.defaultExpectation.expectationOrigins.origin, *m.AcceptOrderDeliveryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptOrderDelivery != nil && afterAcceptOrderDeliveryCounter < 1 {
		m.t.Errorf("Expected call to IPVZOrderUseCaseMock.AcceptOrderDelivery at\n%s", m.funcAcceptOrderDeliveryOrigin)
	}

	if !m.AcceptOrderDeliveryMock.invocationsDone() && afterAcceptOrderDeliveryCounter > 0 {
		m.t.Errorf("Expected %d calls to IPVZOrderUseCaseMock.AcceptOrderDelivery at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AcceptOrderDeliveryMock.expectedInvocations), m.AcceptOrderDeliveryMock.expectedInvocationsOrigin, afterAcceptOrderDeliveryCounter)
	}
}

type mIPVZOrderUseCaseMockAcceptReturn struct {
	optional           bool
	mock               *IPVZOrderUseCaseMock
	defaultExpectation *IPVZOrderUseCaseMockAcceptReturnExpectation
	expectations       []*IPVZOrderUseCaseMockAcceptReturnExpectation

	callArgs []*IPVZOrderUseCaseMockAcceptReturnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IPVZOrderUseCaseMockAcceptReturnExpectation specifies expectation struct of the IPVZOrderUseCase.AcceptReturn
type IPVZOrderUseCaseMockAcceptReturnExpectation struct {
	mock               *IPVZOrderUseCaseMock
	params             *IPVZOrderUseCaseMockAcceptReturnParams
	paramPtrs          *IPVZOrderUseCaseMockAcceptReturnParamPtrs
	expectationOrigins IPVZOrderUseCaseMockAcceptReturnExpectationOrigins
	results            *IPVZOrderUseCaseMockAcceptReturnResults
	returnOrigin       string
	Counter            uint64
}

// IPVZOrderUseCaseMockAcceptReturnParams contains parameters of the IPVZOrderUseCase.AcceptReturn
type IPVZOrderUseCaseMockAcceptReturnParams struct {
	ctx     context.Context
	userID  string
	orderID string
}

// IPVZOrderUseCaseMockAcceptReturnParamPtrs contains pointers to parameters of the IPVZOrderUseCase.AcceptReturn
type IPVZOrderUseCaseMockAcceptReturnParamPtrs struct {
	ctx     *context.Context
	userID  *string
	orderID *string
}

// IPVZOrderUseCaseMockAcceptReturnResults contains results of the IPVZOrderUseCase.AcceptReturn
type IPVZOrderUseCaseMockAcceptReturnResults struct {
	err error
}

// IPVZOrderUseCaseMockAcceptReturnOrigins contains origins of expectations of the IPVZOrderUseCase.AcceptReturn
type IPVZOrderUseCaseMockAcceptReturnExpectationOrigins struct {
	origin        string
	originCtx     string
	originUserID  string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAcceptReturn *mIPVZOrderUseCaseMockAcceptReturn) Optional() *mIPVZOrderUseCaseMockAcceptReturn {
	mmAcceptReturn.optional = true
	return mmAcceptReturn
}

// Expect sets up expected params for IPVZOrderUseCase.AcceptReturn
func (mmAcceptReturn *mIPVZOrderUseCaseMockAcceptReturn) Expect(ctx context.Context, userID string, orderID string) *mIPVZOrderUseCaseMockAcceptReturn {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptReturn mock is already set by Set")
	}

	if mmAcceptReturn.defaultExpectation == nil {
		mmAcceptReturn.defaultExpectation = &IPVZOrderUseCaseMockAcceptReturnExpectation{}
	}

	if mmAcceptReturn.defaultExpectation.paramPtrs != nil {
		mmAcceptReturn.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptReturn mock is already set by ExpectParams functions")
	}

	mmAcceptReturn.defaultExpectation.params = &IPVZOrderUseCaseMockAcceptReturnParams{ctx, userID, orderID}
	mmAcceptReturn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAcceptReturn.expectations {
		if minimock.Equal(e.params, mmAcceptReturn.defaultExpectation.params) {
			mmAcceptReturn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptReturn.defaultExpectation.params)
		}
	}

	return mmAcceptReturn
}

// ExpectCtxParam1 sets up expected param ctx for IPVZOrderUseCase.AcceptReturn
func (mmAcceptReturn *mIPVZOrderUseCaseMockAcceptReturn) ExpectCtxParam1(ctx context.Context) *mIPVZOrderUseCaseMockAcceptReturn {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptReturn mock is already set by Set")
	}

	if mmAcceptReturn.defaultExpectation == nil {
		mmAcceptReturn.defaultExpectation = &IPVZOrderUseCaseMockAcceptReturnExpectation{}
	}

	if mmAcceptReturn.defaultExpectation.params != nil {
		mmAcceptReturn.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptReturn mock is already set by Expect")
	}

	if mmAcceptReturn.defaultExpectation.paramPtrs == nil {
		mmAcceptReturn.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockAcceptReturnParamPtrs{}
	}
	mmAcceptReturn.defaultExpectation.paramPtrs.ctx = &ctx
	mmAcceptReturn.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAcceptReturn
}

// ExpectUserIDParam2 sets up expected param userID for IPVZOrderUseCase.AcceptReturn
func (mmAcceptReturn *mIPVZOrderUseCaseMockAcceptReturn) ExpectUserIDParam2(userID string) *mIPVZOrderUseCaseMockAcceptReturn {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptReturn mock is already set by Set")
	}

	if mmAcceptReturn.defaultExpectation == nil {
		mmAcceptReturn.defaultExpectation = &IPVZOrderUseCaseMockAcceptReturnExpectation{}
	}

	if mmAcceptReturn.defaultExpectation.params != nil {
		mmAcceptReturn.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptReturn mock is already set by Expect")
	}

	if mmAcceptReturn.defaultExpectation.paramPtrs == nil {
		mmAcceptReturn.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockAcceptReturnParamPtrs{}
	}
	mmAcceptReturn.defaultExpectation.paramPtrs.userID = &userID
	mmAcceptReturn.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmAcceptReturn
}

// ExpectOrderIDParam3 sets up expected param orderID for IPVZOrderUseCase.AcceptReturn
func (mmAcceptReturn *mIPVZOrderUseCaseMockAcceptReturn) ExpectOrderIDParam3(orderID string) *mIPVZOrderUseCaseMockAcceptReturn {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptReturn mock is already set by Set")
	}

	if mmAcceptReturn.defaultExpectation == nil {
		mmAcceptReturn.defaultExpectation = &IPVZOrderUseCaseMockAcceptReturnExpectation{}
	}

	if mmAcceptReturn.defaultExpectation.params != nil {
		mmAcceptReturn.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptReturn mock is already set by Expect")
	}

	if mmAcceptReturn.defaultExpectation.paramPtrs == nil {
		mmAcceptReturn.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockAcceptReturnParamPtrs{}
	}
	mmAcceptReturn.defaultExpectation.paramPtrs.orderID = &orderID
	mmAcceptReturn.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmAcceptReturn
}

// Inspect accepts an inspector function that has same arguments as the IPVZOrderUseCase.AcceptReturn
func (mmAcceptReturn *mIPVZOrderUseCaseMockAcceptReturn) Inspect(f func(ctx context.Context, userID string, orderID string)) *mIPVZOrderUseCaseMockAcceptReturn {
	if mmAcceptReturn.mock.inspectFuncAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("Inspect function is already set for IPVZOrderUseCaseMock.AcceptReturn")
	}

	mmAcceptReturn.mock.inspectFuncAcceptReturn = f

	return mmAcceptReturn
}

// Return sets up results that will be returned by IPVZOrderUseCase.AcceptReturn
func (mmAcceptReturn *mIPVZOrderUseCaseMockAcceptReturn) Return(err error) *IPVZOrderUseCaseMock {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptReturn mock is already set by Set")
	}

	if mmAcceptReturn.defaultExpectation == nil {
		mmAcceptReturn.defaultExpectation = &IPVZOrderUseCaseMockAcceptReturnExpectation{mock: mmAcceptReturn.mock}
	}
	mmAcceptReturn.defaultExpectation.results = &IPVZOrderUseCaseMockAcceptReturnResults{err}
	mmAcceptReturn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAcceptReturn.mock
}

// Set uses given function f to mock the IPVZOrderUseCase.AcceptReturn method
func (mmAcceptReturn *mIPVZOrderUseCaseMockAcceptReturn) Set(f func(ctx context.Context, userID string, orderID string) (err error)) *IPVZOrderUseCaseMock {
	if mmAcceptReturn.defaultExpectation != nil {
		mmAcceptReturn.mock.t.Fatalf("Default expectation is already set for the IPVZOrderUseCase.AcceptReturn method")
	}

	if len(mmAcceptReturn.expectations) > 0 {
		mmAcceptReturn.mock.t.Fatalf("Some expectations are already set for the IPVZOrderUseCase.AcceptReturn method")
	}

	mmAcceptReturn.mock.funcAcceptReturn = f
	mmAcceptReturn.mock.funcAcceptReturnOrigin = minimock.CallerInfo(1)
	return mmAcceptReturn.mock
}

// When sets expectation for the IPVZOrderUseCase.AcceptReturn which will trigger the result defined by the following
// Then helper
func (mmAcceptReturn *mIPVZOrderUseCaseMockAcceptReturn) When(ctx context.Context, userID string, orderID string) *IPVZOrderUseCaseMockAcceptReturnExpectation {
	if mmAcceptReturn.mock.funcAcceptReturn != nil {
		mmAcceptReturn.mock.t.Fatalf("IPVZOrderUseCaseMock.AcceptReturn mock is already set by Set")
	}

	expectation := &IPVZOrderUseCaseMockAcceptReturnExpectation{
		mock:               mmAcceptReturn.mock,
		params:             &IPVZOrderUseCaseMockAcceptReturnParams{ctx, userID, orderID},
		expectationOrigins: IPVZOrderUseCaseMockAcceptReturnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAcceptReturn.expectations = append(mmAcceptReturn.expectations, expectation)
	return expectation
}

// Then sets up IPVZOrderUseCase.AcceptReturn return parameters for the expectation previously defined by the When method
func (e *IPVZOrderUseCaseMockAcceptReturnExpectation) Then(err error) *IPVZOrderUseCaseMock {
	e.results = &IPVZOrderUseCaseMockAcceptReturnResults{err}
	return e.mock
}

// Times sets number of times IPVZOrderUseCase.AcceptReturn should be invoked
func (mmAcceptReturn *mIPVZOrderUseCaseMockAcceptReturn) Times(n uint64) *mIPVZOrderUseCaseMockAcceptReturn {
	if n == 0 {
		mmAcceptReturn.mock.t.Fatalf("Times of IPVZOrderUseCaseMock.AcceptReturn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcceptReturn.expectedInvocations, n)
	mmAcceptReturn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAcceptReturn
}

func (mmAcceptReturn *mIPVZOrderUseCaseMockAcceptReturn) invocationsDone() bool {
	if len(mmAcceptReturn.expectations) == 0 && mmAcceptReturn.defaultExpectation == nil && mmAcceptReturn.mock.funcAcceptReturn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAcceptReturn.mock.afterAcceptReturnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcceptReturn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AcceptReturn implements mm_abstractions.IPVZOrderUseCase
func (mmAcceptReturn *IPVZOrderUseCaseMock) AcceptReturn(ctx context.Context, userID string, orderID string) (err error) {
	mm_atomic.AddUint64(&mmAcceptReturn.beforeAcceptReturnCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptReturn.afterAcceptReturnCounter, 1)

	mmAcceptReturn.t.Helper()

	if mmAcceptReturn.inspectFuncAcceptReturn != nil {
		mmAcceptReturn.inspectFuncAcceptReturn(ctx, userID, orderID)
	}

	mm_params := IPVZOrderUseCaseMockAcceptReturnParams{ctx, userID, orderID}

	// Record call args
	mmAcceptReturn.AcceptReturnMock.mutex.Lock()
	mmAcceptReturn.AcceptReturnMock.callArgs = append(mmAcceptReturn.AcceptReturnMock.callArgs, &mm_params)
	mmAcceptReturn.AcceptReturnMock.mutex.Unlock()

	for _, e := range mmAcceptReturn.AcceptReturnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAcceptReturn.AcceptReturnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptReturn.AcceptReturnMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptReturn.AcceptReturnMock.defaultExpectation.params
		mm_want_ptrs := mmAcceptReturn.AcceptReturnMock.defaultExpectation.paramPtrs

		mm_got := IPVZOrderUseCaseMockAcceptReturnParams{ctx, userID, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAcceptReturn.t.Errorf("IPVZOrderUseCaseMock.AcceptReturn got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptReturn.AcceptReturnMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAcceptReturn.t.Errorf("IPVZOrderUseCaseMock.AcceptReturn got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptReturn.AcceptReturnMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmAcceptReturn.t.Errorf("IPVZOrderUseCaseMock.AcceptReturn got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptReturn.AcceptReturnMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptReturn.t.Errorf("IPVZOrderUseCaseMock.AcceptReturn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAcceptReturn.AcceptReturnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcceptReturn.AcceptReturnMock.defaultExpectation.results
		if mm_results == nil {
			mmAcceptReturn.t.Fatal("No results are set for the IPVZOrderUseCaseMock.AcceptReturn")
		}
		return (*mm_results).err
	}
	if mmAcceptReturn.funcAcceptReturn != nil {
		return mmAcceptReturn.funcAcceptReturn(ctx, userID, orderID)
	}
	mmAcceptReturn.t.Fatalf("Unexpected call to IPVZOrderUseCaseMock.AcceptReturn. %v %v %v", ctx, userID, orderID)
	return
}

// AcceptReturnAfterCounter returns a count of finished IPVZOrderUseCaseMock.AcceptReturn invocations
func (mmAcceptReturn *IPVZOrderUseCaseMock) AcceptReturnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptReturn.afterAcceptReturnCounter)
}

// AcceptReturnBeforeCounter returns a count of IPVZOrderUseCaseMock.AcceptReturn invocations
func (mmAcceptReturn *IPVZOrderUseCaseMock) AcceptReturnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptReturn.beforeAcceptReturnCounter)
}

// Calls returns a list of arguments used in each call to IPVZOrderUseCaseMock.AcceptReturn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptReturn *mIPVZOrderUseCaseMockAcceptReturn) Calls() []*IPVZOrderUseCaseMockAcceptReturnParams {
	mmAcceptReturn.mutex.RLock()

	argCopy := make([]*IPVZOrderUseCaseMockAcceptReturnParams, len(mmAcceptReturn.callArgs))
	copy(argCopy, mmAcceptReturn.callArgs)

	mmAcceptReturn.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptReturnDone returns true if the count of the AcceptReturn invocations corresponds
// the number of defined expectations
func (m *IPVZOrderUseCaseMock) MinimockAcceptReturnDone() bool {
	if m.AcceptReturnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AcceptReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcceptReturnMock.invocationsDone()
}

// MinimockAcceptReturnInspect logs each unmet expectation
func (m *IPVZOrderUseCaseMock) MinimockAcceptReturnInspect() {
	for _, e := range m.AcceptReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.AcceptReturn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAcceptReturnCounter := mm_atomic.LoadUint64(&m.afterAcceptReturnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptReturnMock.defaultExpectation != nil && afterAcceptReturnCounter < 1 {
		if m.AcceptReturnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.AcceptReturn at\n%s", m.AcceptReturnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.AcceptReturn at\n%s with params: %#v", m.AcceptReturnMock.defaultExpectation.expectationOrigins.origin, *m.AcceptReturnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptReturn != nil && afterAcceptReturnCounter < 1 {
		m.t.Errorf("Expected call to IPVZOrderUseCaseMock.AcceptReturn at\n%s", m.funcAcceptReturnOrigin)
	}

	if !m.AcceptReturnMock.invocationsDone() && afterAcceptReturnCounter > 0 {
		m.t.Errorf("Expected %d calls to IPVZOrderUseCaseMock.AcceptReturn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AcceptReturnMock.expectedInvocations), m.AcceptReturnMock.expectedInvocationsOrigin, afterAcceptReturnCounter)
	}
}

type mIPVZOrderUseCaseMockGetOrders struct {
	optional           bool
	mock               *IPVZOrderUseCaseMock
	defaultExpectation *IPVZOrderUseCaseMockGetOrdersExpectation
	expectations       []*IPVZOrderUseCaseMockGetOrdersExpectation

	callArgs []*IPVZOrderUseCaseMockGetOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IPVZOrderUseCaseMockGetOrdersExpectation specifies expectation struct of the IPVZOrderUseCase.GetOrders
type IPVZOrderUseCaseMockGetOrdersExpectation struct {
	mock               *IPVZOrderUseCaseMock
	params             *IPVZOrderUseCaseMockGetOrdersParams
	paramPtrs          *IPVZOrderUseCaseMockGetOrdersParamPtrs
	expectationOrigins IPVZOrderUseCaseMockGetOrdersExpectationOrigins
	results            *IPVZOrderUseCaseMockGetOrdersResults
	returnOrigin       string
	Counter            uint64
}

// IPVZOrderUseCaseMockGetOrdersParams contains parameters of the IPVZOrderUseCase.GetOrders
type IPVZOrderUseCaseMockGetOrdersParams struct {
	ctx     context.Context
	userID  string
	options []mm_abstractions.GetOrdersOptFunc
}

// IPVZOrderUseCaseMockGetOrdersParamPtrs contains pointers to parameters of the IPVZOrderUseCase.GetOrders
type IPVZOrderUseCaseMockGetOrdersParamPtrs struct {
	ctx     *context.Context
	userID  *string
	options *[]mm_abstractions.GetOrdersOptFunc
}

// IPVZOrderUseCaseMockGetOrdersResults contains results of the IPVZOrderUseCase.GetOrders
type IPVZOrderUseCaseMockGetOrdersResults struct {
	pa1 []domain.PVZOrder
	err error
}

// IPVZOrderUseCaseMockGetOrdersOrigins contains origins of expectations of the IPVZOrderUseCase.GetOrders
type IPVZOrderUseCaseMockGetOrdersExpectationOrigins struct {
	origin        string
	originCtx     string
	originUserID  string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrders *mIPVZOrderUseCaseMockGetOrders) Optional() *mIPVZOrderUseCaseMockGetOrders {
	mmGetOrders.optional = true
	return mmGetOrders
}

// Expect sets up expected params for IPVZOrderUseCase.GetOrders
func (mmGetOrders *mIPVZOrderUseCaseMockGetOrders) Expect(ctx context.Context, userID string, options ...mm_abstractions.GetOrdersOptFunc) *mIPVZOrderUseCaseMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("IPVZOrderUseCaseMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &IPVZOrderUseCaseMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.paramPtrs != nil {
		mmGetOrders.mock.t.Fatalf("IPVZOrderUseCaseMock.GetOrders mock is already set by ExpectParams functions")
	}

	mmGetOrders.defaultExpectation.params = &IPVZOrderUseCaseMockGetOrdersParams{ctx, userID, options}
	mmGetOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrders.expectations {
		if minimock.Equal(e.params, mmGetOrders.defaultExpectation.params) {
			mmGetOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrders.defaultExpectation.params)
		}
	}

	return mmGetOrders
}

// ExpectCtxParam1 sets up expected param ctx for IPVZOrderUseCase.GetOrders
func (mmGetOrders *mIPVZOrderUseCaseMockGetOrders) ExpectCtxParam1(ctx context.Context) *mIPVZOrderUseCaseMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("IPVZOrderUseCaseMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &IPVZOrderUseCaseMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("IPVZOrderUseCaseMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrders
}

// ExpectUserIDParam2 sets up expected param userID for IPVZOrderUseCase.GetOrders
func (mmGetOrders *mIPVZOrderUseCaseMockGetOrders) ExpectUserIDParam2(userID string) *mIPVZOrderUseCaseMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("IPVZOrderUseCaseMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &IPVZOrderUseCaseMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("IPVZOrderUseCaseMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.userID = &userID
	mmGetOrders.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetOrders
}

// ExpectOptionsParam3 sets up expected param options for IPVZOrderUseCase.GetOrders
func (mmGetOrders *mIPVZOrderUseCaseMockGetOrders) ExpectOptionsParam3(options ...mm_abstractions.GetOrdersOptFunc) *mIPVZOrderUseCaseMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("IPVZOrderUseCaseMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &IPVZOrderUseCaseMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("IPVZOrderUseCaseMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.options = &options
	mmGetOrders.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmGetOrders
}

// Inspect accepts an inspector function that has same arguments as the IPVZOrderUseCase.GetOrders
func (mmGetOrders *mIPVZOrderUseCaseMockGetOrders) Inspect(f func(ctx context.Context, userID string, options ...mm_abstractions.GetOrdersOptFunc)) *mIPVZOrderUseCaseMockGetOrders {
	if mmGetOrders.mock.inspectFuncGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("Inspect function is already set for IPVZOrderUseCaseMock.GetOrders")
	}

	mmGetOrders.mock.inspectFuncGetOrders = f

	return mmGetOrders
}

// Return sets up results that will be returned by IPVZOrderUseCase.GetOrders
func (mmGetOrders *mIPVZOrderUseCaseMockGetOrders) Return(pa1 []domain.PVZOrder, err error) *IPVZOrderUseCaseMock {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("IPVZOrderUseCaseMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &IPVZOrderUseCaseMockGetOrdersExpectation{mock: mmGetOrders.mock}
	}
	mmGetOrders.defaultExpectation.results = &IPVZOrderUseCaseMockGetOrdersResults{pa1, err}
	mmGetOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrders.mock
}

// Set uses given function f to mock the IPVZOrderUseCase.GetOrders method
func (mmGetOrders *mIPVZOrderUseCaseMockGetOrders) Set(f func(ctx context.Context, userID string, options ...mm_abstractions.GetOrdersOptFunc) (pa1 []domain.PVZOrder, err error)) *IPVZOrderUseCaseMock {
	if mmGetOrders.defaultExpectation != nil {
		mmGetOrders.mock.t.Fatalf("Default expectation is already set for the IPVZOrderUseCase.GetOrders method")
	}

	if len(mmGetOrders.expectations) > 0 {
		mmGetOrders.mock.t.Fatalf("Some expectations are already set for the IPVZOrderUseCase.GetOrders method")
	}

	mmGetOrders.mock.funcGetOrders = f
	mmGetOrders.mock.funcGetOrdersOrigin = minimock.CallerInfo(1)
	return mmGetOrders.mock
}

// When sets expectation for the IPVZOrderUseCase.GetOrders which will trigger the result defined by the following
// Then helper
func (mmGetOrders *mIPVZOrderUseCaseMockGetOrders) When(ctx context.Context, userID string, options ...mm_abstractions.GetOrdersOptFunc) *IPVZOrderUseCaseMockGetOrdersExpectation {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("IPVZOrderUseCaseMock.GetOrders mock is already set by Set")
	}

	expectation := &IPVZOrderUseCaseMockGetOrdersExpectation{
		mock:               mmGetOrders.mock,
		params:             &IPVZOrderUseCaseMockGetOrdersParams{ctx, userID, options},
		expectationOrigins: IPVZOrderUseCaseMockGetOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrders.expectations = append(mmGetOrders.expectations, expectation)
	return expectation
}

// Then sets up IPVZOrderUseCase.GetOrders return parameters for the expectation previously defined by the When method
func (e *IPVZOrderUseCaseMockGetOrdersExpectation) Then(pa1 []domain.PVZOrder, err error) *IPVZOrderUseCaseMock {
	e.results = &IPVZOrderUseCaseMockGetOrdersResults{pa1, err}
	return e.mock
}

// Times sets number of times IPVZOrderUseCase.GetOrders should be invoked
func (mmGetOrders *mIPVZOrderUseCaseMockGetOrders) Times(n uint64) *mIPVZOrderUseCaseMockGetOrders {
	if n == 0 {
		mmGetOrders.mock.t.Fatalf("Times of IPVZOrderUseCaseMock.GetOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrders.expectedInvocations, n)
	mmGetOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrders
}

func (mmGetOrders *mIPVZOrderUseCaseMockGetOrders) invocationsDone() bool {
	if len(mmGetOrders.expectations) == 0 && mmGetOrders.defaultExpectation == nil && mmGetOrders.mock.funcGetOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrders.mock.afterGetOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrders implements mm_abstractions.IPVZOrderUseCase
func (mmGetOrders *IPVZOrderUseCaseMock) GetOrders(ctx context.Context, userID string, options ...mm_abstractions.GetOrdersOptFunc) (pa1 []domain.PVZOrder, err error) {
	mm_atomic.AddUint64(&mmGetOrders.beforeGetOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrders.afterGetOrdersCounter, 1)

	mmGetOrders.t.Helper()

	if mmGetOrders.inspectFuncGetOrders != nil {
		mmGetOrders.inspectFuncGetOrders(ctx, userID, options...)
	}

	mm_params := IPVZOrderUseCaseMockGetOrdersParams{ctx, userID, options}

	// Record call args
	mmGetOrders.GetOrdersMock.mutex.Lock()
	mmGetOrders.GetOrdersMock.callArgs = append(mmGetOrders.GetOrdersMock.callArgs, &mm_params)
	mmGetOrders.GetOrdersMock.mutex.Unlock()

	for _, e := range mmGetOrders.GetOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetOrders.GetOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrders.GetOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrders.GetOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrders.GetOrdersMock.defaultExpectation.paramPtrs

		mm_got := IPVZOrderUseCaseMockGetOrdersParams{ctx, userID, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrders.t.Errorf("IPVZOrderUseCaseMock.GetOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetOrders.t.Errorf("IPVZOrderUseCaseMock.GetOrders got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmGetOrders.t.Errorf("IPVZOrderUseCaseMock.GetOrders got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrders.t.Errorf("IPVZOrderUseCaseMock.GetOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrders.GetOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrders.t.Fatal("No results are set for the IPVZOrderUseCaseMock.GetOrders")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetOrders.funcGetOrders != nil {
		return mmGetOrders.funcGetOrders(ctx, userID, options...)
	}
	mmGetOrders.t.Fatalf("Unexpected call to IPVZOrderUseCaseMock.GetOrders. %v %v %v", ctx, userID, options)
	return
}

// GetOrdersAfterCounter returns a count of finished IPVZOrderUseCaseMock.GetOrders invocations
func (mmGetOrders *IPVZOrderUseCaseMock) GetOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrders.afterGetOrdersCounter)
}

// GetOrdersBeforeCounter returns a count of IPVZOrderUseCaseMock.GetOrders invocations
func (mmGetOrders *IPVZOrderUseCaseMock) GetOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrders.beforeGetOrdersCounter)
}

// Calls returns a list of arguments used in each call to IPVZOrderUseCaseMock.GetOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrders *mIPVZOrderUseCaseMockGetOrders) Calls() []*IPVZOrderUseCaseMockGetOrdersParams {
	mmGetOrders.mutex.RLock()

	argCopy := make([]*IPVZOrderUseCaseMockGetOrdersParams, len(mmGetOrders.callArgs))
	copy(argCopy, mmGetOrders.callArgs)

	mmGetOrders.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrdersDone returns true if the count of the GetOrders invocations corresponds
// the number of defined expectations
func (m *IPVZOrderUseCaseMock) MinimockGetOrdersDone() bool {
	if m.GetOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrdersMock.invocationsDone()
}

// MinimockGetOrdersInspect logs each unmet expectation
func (m *IPVZOrderUseCaseMock) MinimockGetOrdersInspect() {
	for _, e := range m.GetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.GetOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrdersCounter := mm_atomic.LoadUint64(&m.afterGetOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrdersMock.defaultExpectation != nil && afterGetOrdersCounter < 1 {
		if m.GetOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.GetOrders at\n%s", m.GetOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.GetOrders at\n%s with params: %#v", m.GetOrdersMock.defaultExpectation.expectationOrigins.origin, *m.GetOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrders != nil && afterGetOrdersCounter < 1 {
		m.t.Errorf("Expected call to IPVZOrderUseCaseMock.GetOrders at\n%s", m.funcGetOrdersOrigin)
	}

	if !m.GetOrdersMock.invocationsDone() && afterGetOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to IPVZOrderUseCaseMock.GetOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrdersMock.expectedInvocations), m.GetOrdersMock.expectedInvocationsOrigin, afterGetOrdersCounter)
	}
}

type mIPVZOrderUseCaseMockGetReturns struct {
	optional           bool
	mock               *IPVZOrderUseCaseMock
	defaultExpectation *IPVZOrderUseCaseMockGetReturnsExpectation
	expectations       []*IPVZOrderUseCaseMockGetReturnsExpectation

	callArgs []*IPVZOrderUseCaseMockGetReturnsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IPVZOrderUseCaseMockGetReturnsExpectation specifies expectation struct of the IPVZOrderUseCase.GetReturns
type IPVZOrderUseCaseMockGetReturnsExpectation struct {
	mock               *IPVZOrderUseCaseMock
	params             *IPVZOrderUseCaseMockGetReturnsParams
	paramPtrs          *IPVZOrderUseCaseMockGetReturnsParamPtrs
	expectationOrigins IPVZOrderUseCaseMockGetReturnsExpectationOrigins
	results            *IPVZOrderUseCaseMockGetReturnsResults
	returnOrigin       string
	Counter            uint64
}

// IPVZOrderUseCaseMockGetReturnsParams contains parameters of the IPVZOrderUseCase.GetReturns
type IPVZOrderUseCaseMockGetReturnsParams struct {
	ctx     context.Context
	options []mm_abstractions.PagePaginationOptFunc
}

// IPVZOrderUseCaseMockGetReturnsParamPtrs contains pointers to parameters of the IPVZOrderUseCase.GetReturns
type IPVZOrderUseCaseMockGetReturnsParamPtrs struct {
	ctx     *context.Context
	options *[]mm_abstractions.PagePaginationOptFunc
}

// IPVZOrderUseCaseMockGetReturnsResults contains results of the IPVZOrderUseCase.GetReturns
type IPVZOrderUseCaseMockGetReturnsResults struct {
	pa1 []domain.PVZOrder
	err error
}

// IPVZOrderUseCaseMockGetReturnsOrigins contains origins of expectations of the IPVZOrderUseCase.GetReturns
type IPVZOrderUseCaseMockGetReturnsExpectationOrigins struct {
	origin        string
	originCtx     string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReturns *mIPVZOrderUseCaseMockGetReturns) Optional() *mIPVZOrderUseCaseMockGetReturns {
	mmGetReturns.optional = true
	return mmGetReturns
}

// Expect sets up expected params for IPVZOrderUseCase.GetReturns
func (mmGetReturns *mIPVZOrderUseCaseMockGetReturns) Expect(ctx context.Context, options ...mm_abstractions.PagePaginationOptFunc) *mIPVZOrderUseCaseMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("IPVZOrderUseCaseMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &IPVZOrderUseCaseMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.paramPtrs != nil {
		mmGetReturns.mock.t.Fatalf("IPVZOrderUseCaseMock.GetReturns mock is already set by ExpectParams functions")
	}

	mmGetReturns.defaultExpectation.params = &IPVZOrderUseCaseMockGetReturnsParams{ctx, options}
	mmGetReturns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReturns.expectations {
		if minimock.Equal(e.params, mmGetReturns.defaultExpectation.params) {
			mmGetReturns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReturns.defaultExpectation.params)
		}
	}

	return mmGetReturns
}

// ExpectCtxParam1 sets up expected param ctx for IPVZOrderUseCase.GetReturns
func (mmGetReturns *mIPVZOrderUseCaseMockGetReturns) ExpectCtxParam1(ctx context.Context) *mIPVZOrderUseCaseMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("IPVZOrderUseCaseMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &IPVZOrderUseCaseMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.params != nil {
		mmGetReturns.mock.t.Fatalf("IPVZOrderUseCaseMock.GetReturns mock is already set by Expect")
	}

	if mmGetReturns.defaultExpectation.paramPtrs == nil {
		mmGetReturns.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockGetReturnsParamPtrs{}
	}
	mmGetReturns.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetReturns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetReturns
}

// ExpectOptionsParam2 sets up expected param options for IPVZOrderUseCase.GetReturns
func (mmGetReturns *mIPVZOrderUseCaseMockGetReturns) ExpectOptionsParam2(options ...mm_abstractions.PagePaginationOptFunc) *mIPVZOrderUseCaseMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("IPVZOrderUseCaseMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &IPVZOrderUseCaseMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.params != nil {
		mmGetReturns.mock.t.Fatalf("IPVZOrderUseCaseMock.GetReturns mock is already set by Expect")
	}

	if mmGetReturns.defaultExpectation.paramPtrs == nil {
		mmGetReturns.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockGetReturnsParamPtrs{}
	}
	mmGetReturns.defaultExpectation.paramPtrs.options = &options
	mmGetReturns.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmGetReturns
}

// Inspect accepts an inspector function that has same arguments as the IPVZOrderUseCase.GetReturns
func (mmGetReturns *mIPVZOrderUseCaseMockGetReturns) Inspect(f func(ctx context.Context, options ...mm_abstractions.PagePaginationOptFunc)) *mIPVZOrderUseCaseMockGetReturns {
	if mmGetReturns.mock.inspectFuncGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("Inspect function is already set for IPVZOrderUseCaseMock.GetReturns")
	}

	mmGetReturns.mock.inspectFuncGetReturns = f

	return mmGetReturns
}

// Return sets up results that will be returned by IPVZOrderUseCase.GetReturns
func (mmGetReturns *mIPVZOrderUseCaseMockGetReturns) Return(pa1 []domain.PVZOrder, err error) *IPVZOrderUseCaseMock {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("IPVZOrderUseCaseMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &IPVZOrderUseCaseMockGetReturnsExpectation{mock: mmGetReturns.mock}
	}
	mmGetReturns.defaultExpectation.results = &IPVZOrderUseCaseMockGetReturnsResults{pa1, err}
	mmGetReturns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReturns.mock
}

// Set uses given function f to mock the IPVZOrderUseCase.GetReturns method
func (mmGetReturns *mIPVZOrderUseCaseMockGetReturns) Set(f func(ctx context.Context, options ...mm_abstractions.PagePaginationOptFunc) (pa1 []domain.PVZOrder, err error)) *IPVZOrderUseCaseMock {
	if mmGetReturns.defaultExpectation != nil {
		mmGetReturns.mock.t.Fatalf("Default expectation is already set for the IPVZOrderUseCase.GetReturns method")
	}

	if len(mmGetReturns.expectations) > 0 {
		mmGetReturns.mock.t.Fatalf("Some expectations are already set for the IPVZOrderUseCase.GetReturns method")
	}

	mmGetReturns.mock.funcGetReturns = f
	mmGetReturns.mock.funcGetReturnsOrigin = minimock.CallerInfo(1)
	return mmGetReturns.mock
}

// When sets expectation for the IPVZOrderUseCase.GetReturns which will trigger the result defined by the following
// Then helper
func (mmGetReturns *mIPVZOrderUseCaseMockGetReturns) When(ctx context.Context, options ...mm_abstractions.PagePaginationOptFunc) *IPVZOrderUseCaseMockGetReturnsExpectation {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("IPVZOrderUseCaseMock.GetReturns mock is already set by Set")
	}

	expectation := &IPVZOrderUseCaseMockGetReturnsExpectation{
		mock:               mmGetReturns.mock,
		params:             &IPVZOrderUseCaseMockGetReturnsParams{ctx, options},
		expectationOrigins: IPVZOrderUseCaseMockGetReturnsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReturns.expectations = append(mmGetReturns.expectations, expectation)
	return expectation
}

// Then sets up IPVZOrderUseCase.GetReturns return parameters for the expectation previously defined by the When method
func (e *IPVZOrderUseCaseMockGetReturnsExpectation) Then(pa1 []domain.PVZOrder, err error) *IPVZOrderUseCaseMock {
	e.results = &IPVZOrderUseCaseMockGetReturnsResults{pa1, err}
	return e.mock
}

// Times sets number of times IPVZOrderUseCase.GetReturns should be invoked
func (mmGetReturns *mIPVZOrderUseCaseMockGetReturns) Times(n uint64) *mIPVZOrderUseCaseMockGetReturns {
	if n == 0 {
		mmGetReturns.mock.t.Fatalf("Times of IPVZOrderUseCaseMock.GetReturns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReturns.expectedInvocations, n)
	mmGetReturns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReturns
}

func (mmGetReturns *mIPVZOrderUseCaseMockGetReturns) invocationsDone() bool {
	if len(mmGetReturns.expectations) == 0 && mmGetReturns.defaultExpectation == nil && mmGetReturns.mock.funcGetReturns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReturns.mock.afterGetReturnsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReturns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReturns implements mm_abstractions.IPVZOrderUseCase
func (mmGetReturns *IPVZOrderUseCaseMock) GetReturns(ctx context.Context, options ...mm_abstractions.PagePaginationOptFunc) (pa1 []domain.PVZOrder, err error) {
	mm_atomic.AddUint64(&mmGetReturns.beforeGetReturnsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReturns.afterGetReturnsCounter, 1)

	mmGetReturns.t.Helper()

	if mmGetReturns.inspectFuncGetReturns != nil {
		mmGetReturns.inspectFuncGetReturns(ctx, options...)
	}

	mm_params := IPVZOrderUseCaseMockGetReturnsParams{ctx, options}

	// Record call args
	mmGetReturns.GetReturnsMock.mutex.Lock()
	mmGetReturns.GetReturnsMock.callArgs = append(mmGetReturns.GetReturnsMock.callArgs, &mm_params)
	mmGetReturns.GetReturnsMock.mutex.Unlock()

	for _, e := range mmGetReturns.GetReturnsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetReturns.GetReturnsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReturns.GetReturnsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReturns.GetReturnsMock.defaultExpectation.params
		mm_want_ptrs := mmGetReturns.GetReturnsMock.defaultExpectation.paramPtrs

		mm_got := IPVZOrderUseCaseMockGetReturnsParams{ctx, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetReturns.t.Errorf("IPVZOrderUseCaseMock.GetReturns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmGetReturns.t.Errorf("IPVZOrderUseCaseMock.GetReturns got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReturns.t.Errorf("IPVZOrderUseCaseMock.GetReturns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReturns.GetReturnsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReturns.t.Fatal("No results are set for the IPVZOrderUseCaseMock.GetReturns")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetReturns.funcGetReturns != nil {
		return mmGetReturns.funcGetReturns(ctx, options...)
	}
	mmGetReturns.t.Fatalf("Unexpected call to IPVZOrderUseCaseMock.GetReturns. %v %v", ctx, options)
	return
}

// GetReturnsAfterCounter returns a count of finished IPVZOrderUseCaseMock.GetReturns invocations
func (mmGetReturns *IPVZOrderUseCaseMock) GetReturnsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturns.afterGetReturnsCounter)
}

// GetReturnsBeforeCounter returns a count of IPVZOrderUseCaseMock.GetReturns invocations
func (mmGetReturns *IPVZOrderUseCaseMock) GetReturnsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturns.beforeGetReturnsCounter)
}

// Calls returns a list of arguments used in each call to IPVZOrderUseCaseMock.GetReturns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReturns *mIPVZOrderUseCaseMockGetReturns) Calls() []*IPVZOrderUseCaseMockGetReturnsParams {
	mmGetReturns.mutex.RLock()

	argCopy := make([]*IPVZOrderUseCaseMockGetReturnsParams, len(mmGetReturns.callArgs))
	copy(argCopy, mmGetReturns.callArgs)

	mmGetReturns.mutex.RUnlock()

	return argCopy
}

// MinimockGetReturnsDone returns true if the count of the GetReturns invocations corresponds
// the number of defined expectations
func (m *IPVZOrderUseCaseMock) MinimockGetReturnsDone() bool {
	if m.GetReturnsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReturnsMock.invocationsDone()
}

// MinimockGetReturnsInspect logs each unmet expectation
func (m *IPVZOrderUseCaseMock) MinimockGetReturnsInspect() {
	for _, e := range m.GetReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.GetReturns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReturnsCounter := mm_atomic.LoadUint64(&m.afterGetReturnsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReturnsMock.defaultExpectation != nil && afterGetReturnsCounter < 1 {
		if m.GetReturnsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.GetReturns at\n%s", m.GetReturnsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.GetReturns at\n%s with params: %#v", m.GetReturnsMock.defaultExpectation.expectationOrigins.origin, *m.GetReturnsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReturns != nil && afterGetReturnsCounter < 1 {
		m.t.Errorf("Expected call to IPVZOrderUseCaseMock.GetReturns at\n%s", m.funcGetReturnsOrigin)
	}

	if !m.GetReturnsMock.invocationsDone() && afterGetReturnsCounter > 0 {
		m.t.Errorf("Expected %d calls to IPVZOrderUseCaseMock.GetReturns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReturnsMock.expectedInvocations), m.GetReturnsMock.expectedInvocationsOrigin, afterGetReturnsCounter)
	}
}

type mIPVZOrderUseCaseMockGiveOrderToClient struct {
	optional           bool
	mock               *IPVZOrderUseCaseMock
	defaultExpectation *IPVZOrderUseCaseMockGiveOrderToClientExpectation
	expectations       []*IPVZOrderUseCaseMockGiveOrderToClientExpectation

	callArgs []*IPVZOrderUseCaseMockGiveOrderToClientParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IPVZOrderUseCaseMockGiveOrderToClientExpectation specifies expectation struct of the IPVZOrderUseCase.GiveOrderToClient
type IPVZOrderUseCaseMockGiveOrderToClientExpectation struct {
	mock               *IPVZOrderUseCaseMock
	params             *IPVZOrderUseCaseMockGiveOrderToClientParams
	paramPtrs          *IPVZOrderUseCaseMockGiveOrderToClientParamPtrs
	expectationOrigins IPVZOrderUseCaseMockGiveOrderToClientExpectationOrigins
	results            *IPVZOrderUseCaseMockGiveOrderToClientResults
	returnOrigin       string
	Counter            uint64
}

// IPVZOrderUseCaseMockGiveOrderToClientParams contains parameters of the IPVZOrderUseCase.GiveOrderToClient
type IPVZOrderUseCaseMockGiveOrderToClientParams struct {
	ctx      context.Context
	orderIDs []string
}

// IPVZOrderUseCaseMockGiveOrderToClientParamPtrs contains pointers to parameters of the IPVZOrderUseCase.GiveOrderToClient
type IPVZOrderUseCaseMockGiveOrderToClientParamPtrs struct {
	ctx      *context.Context
	orderIDs *[]string
}

// IPVZOrderUseCaseMockGiveOrderToClientResults contains results of the IPVZOrderUseCase.GiveOrderToClient
type IPVZOrderUseCaseMockGiveOrderToClientResults struct {
	err error
}

// IPVZOrderUseCaseMockGiveOrderToClientOrigins contains origins of expectations of the IPVZOrderUseCase.GiveOrderToClient
type IPVZOrderUseCaseMockGiveOrderToClientExpectationOrigins struct {
	origin         string
	originCtx      string
	originOrderIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGiveOrderToClient *mIPVZOrderUseCaseMockGiveOrderToClient) Optional() *mIPVZOrderUseCaseMockGiveOrderToClient {
	mmGiveOrderToClient.optional = true
	return mmGiveOrderToClient
}

// Expect sets up expected params for IPVZOrderUseCase.GiveOrderToClient
func (mmGiveOrderToClient *mIPVZOrderUseCaseMockGiveOrderToClient) Expect(ctx context.Context, orderIDs []string) *mIPVZOrderUseCaseMockGiveOrderToClient {
	if mmGiveOrderToClient.mock.funcGiveOrderToClient != nil {
		mmGiveOrderToClient.mock.t.Fatalf("IPVZOrderUseCaseMock.GiveOrderToClient mock is already set by Set")
	}

	if mmGiveOrderToClient.defaultExpectation == nil {
		mmGiveOrderToClient.defaultExpectation = &IPVZOrderUseCaseMockGiveOrderToClientExpectation{}
	}

	if mmGiveOrderToClient.defaultExpectation.paramPtrs != nil {
		mmGiveOrderToClient.mock.t.Fatalf("IPVZOrderUseCaseMock.GiveOrderToClient mock is already set by ExpectParams functions")
	}

	mmGiveOrderToClient.defaultExpectation.params = &IPVZOrderUseCaseMockGiveOrderToClientParams{ctx, orderIDs}
	mmGiveOrderToClient.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGiveOrderToClient.expectations {
		if minimock.Equal(e.params, mmGiveOrderToClient.defaultExpectation.params) {
			mmGiveOrderToClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGiveOrderToClient.defaultExpectation.params)
		}
	}

	return mmGiveOrderToClient
}

// ExpectCtxParam1 sets up expected param ctx for IPVZOrderUseCase.GiveOrderToClient
func (mmGiveOrderToClient *mIPVZOrderUseCaseMockGiveOrderToClient) ExpectCtxParam1(ctx context.Context) *mIPVZOrderUseCaseMockGiveOrderToClient {
	if mmGiveOrderToClient.mock.funcGiveOrderToClient != nil {
		mmGiveOrderToClient.mock.t.Fatalf("IPVZOrderUseCaseMock.GiveOrderToClient mock is already set by Set")
	}

	if mmGiveOrderToClient.defaultExpectation == nil {
		mmGiveOrderToClient.defaultExpectation = &IPVZOrderUseCaseMockGiveOrderToClientExpectation{}
	}

	if mmGiveOrderToClient.defaultExpectation.params != nil {
		mmGiveOrderToClient.mock.t.Fatalf("IPVZOrderUseCaseMock.GiveOrderToClient mock is already set by Expect")
	}

	if mmGiveOrderToClient.defaultExpectation.paramPtrs == nil {
		mmGiveOrderToClient.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockGiveOrderToClientParamPtrs{}
	}
	mmGiveOrderToClient.defaultExpectation.paramPtrs.ctx = &ctx
	mmGiveOrderToClient.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGiveOrderToClient
}

// ExpectOrderIDsParam2 sets up expected param orderIDs for IPVZOrderUseCase.GiveOrderToClient
func (mmGiveOrderToClient *mIPVZOrderUseCaseMockGiveOrderToClient) ExpectOrderIDsParam2(orderIDs []string) *mIPVZOrderUseCaseMockGiveOrderToClient {
	if mmGiveOrderToClient.mock.funcGiveOrderToClient != nil {
		mmGiveOrderToClient.mock.t.Fatalf("IPVZOrderUseCaseMock.GiveOrderToClient mock is already set by Set")
	}

	if mmGiveOrderToClient.defaultExpectation == nil {
		mmGiveOrderToClient.defaultExpectation = &IPVZOrderUseCaseMockGiveOrderToClientExpectation{}
	}

	if mmGiveOrderToClient.defaultExpectation.params != nil {
		mmGiveOrderToClient.mock.t.Fatalf("IPVZOrderUseCaseMock.GiveOrderToClient mock is already set by Expect")
	}

	if mmGiveOrderToClient.defaultExpectation.paramPtrs == nil {
		mmGiveOrderToClient.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockGiveOrderToClientParamPtrs{}
	}
	mmGiveOrderToClient.defaultExpectation.paramPtrs.orderIDs = &orderIDs
	mmGiveOrderToClient.defaultExpectation.expectationOrigins.originOrderIDs = minimock.CallerInfo(1)

	return mmGiveOrderToClient
}

// Inspect accepts an inspector function that has same arguments as the IPVZOrderUseCase.GiveOrderToClient
func (mmGiveOrderToClient *mIPVZOrderUseCaseMockGiveOrderToClient) Inspect(f func(ctx context.Context, orderIDs []string)) *mIPVZOrderUseCaseMockGiveOrderToClient {
	if mmGiveOrderToClient.mock.inspectFuncGiveOrderToClient != nil {
		mmGiveOrderToClient.mock.t.Fatalf("Inspect function is already set for IPVZOrderUseCaseMock.GiveOrderToClient")
	}

	mmGiveOrderToClient.mock.inspectFuncGiveOrderToClient = f

	return mmGiveOrderToClient
}

// Return sets up results that will be returned by IPVZOrderUseCase.GiveOrderToClient
func (mmGiveOrderToClient *mIPVZOrderUseCaseMockGiveOrderToClient) Return(err error) *IPVZOrderUseCaseMock {
	if mmGiveOrderToClient.mock.funcGiveOrderToClient != nil {
		mmGiveOrderToClient.mock.t.Fatalf("IPVZOrderUseCaseMock.GiveOrderToClient mock is already set by Set")
	}

	if mmGiveOrderToClient.defaultExpectation == nil {
		mmGiveOrderToClient.defaultExpectation = &IPVZOrderUseCaseMockGiveOrderToClientExpectation{mock: mmGiveOrderToClient.mock}
	}
	mmGiveOrderToClient.defaultExpectation.results = &IPVZOrderUseCaseMockGiveOrderToClientResults{err}
	mmGiveOrderToClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGiveOrderToClient.mock
}

// Set uses given function f to mock the IPVZOrderUseCase.GiveOrderToClient method
func (mmGiveOrderToClient *mIPVZOrderUseCaseMockGiveOrderToClient) Set(f func(ctx context.Context, orderIDs []string) (err error)) *IPVZOrderUseCaseMock {
	if mmGiveOrderToClient.defaultExpectation != nil {
		mmGiveOrderToClient.mock.t.Fatalf("Default expectation is already set for the IPVZOrderUseCase.GiveOrderToClient method")
	}

	if len(mmGiveOrderToClient.expectations) > 0 {
		mmGiveOrderToClient.mock.t.Fatalf("Some expectations are already set for the IPVZOrderUseCase.GiveOrderToClient method")
	}

	mmGiveOrderToClient.mock.funcGiveOrderToClient = f
	mmGiveOrderToClient.mock.funcGiveOrderToClientOrigin = minimock.CallerInfo(1)
	return mmGiveOrderToClient.mock
}

// When sets expectation for the IPVZOrderUseCase.GiveOrderToClient which will trigger the result defined by the following
// Then helper
func (mmGiveOrderToClient *mIPVZOrderUseCaseMockGiveOrderToClient) When(ctx context.Context, orderIDs []string) *IPVZOrderUseCaseMockGiveOrderToClientExpectation {
	if mmGiveOrderToClient.mock.funcGiveOrderToClient != nil {
		mmGiveOrderToClient.mock.t.Fatalf("IPVZOrderUseCaseMock.GiveOrderToClient mock is already set by Set")
	}

	expectation := &IPVZOrderUseCaseMockGiveOrderToClientExpectation{
		mock:               mmGiveOrderToClient.mock,
		params:             &IPVZOrderUseCaseMockGiveOrderToClientParams{ctx, orderIDs},
		expectationOrigins: IPVZOrderUseCaseMockGiveOrderToClientExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGiveOrderToClient.expectations = append(mmGiveOrderToClient.expectations, expectation)
	return expectation
}

// Then sets up IPVZOrderUseCase.GiveOrderToClient return parameters for the expectation previously defined by the When method
func (e *IPVZOrderUseCaseMockGiveOrderToClientExpectation) Then(err error) *IPVZOrderUseCaseMock {
	e.results = &IPVZOrderUseCaseMockGiveOrderToClientResults{err}
	return e.mock
}

// Times sets number of times IPVZOrderUseCase.GiveOrderToClient should be invoked
func (mmGiveOrderToClient *mIPVZOrderUseCaseMockGiveOrderToClient) Times(n uint64) *mIPVZOrderUseCaseMockGiveOrderToClient {
	if n == 0 {
		mmGiveOrderToClient.mock.t.Fatalf("Times of IPVZOrderUseCaseMock.GiveOrderToClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGiveOrderToClient.expectedInvocations, n)
	mmGiveOrderToClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGiveOrderToClient
}

func (mmGiveOrderToClient *mIPVZOrderUseCaseMockGiveOrderToClient) invocationsDone() bool {
	if len(mmGiveOrderToClient.expectations) == 0 && mmGiveOrderToClient.defaultExpectation == nil && mmGiveOrderToClient.mock.funcGiveOrderToClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGiveOrderToClient.mock.afterGiveOrderToClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGiveOrderToClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GiveOrderToClient implements mm_abstractions.IPVZOrderUseCase
func (mmGiveOrderToClient *IPVZOrderUseCaseMock) GiveOrderToClient(ctx context.Context, orderIDs []string) (err error) {
	mm_atomic.AddUint64(&mmGiveOrderToClient.beforeGiveOrderToClientCounter, 1)
	defer mm_atomic.AddUint64(&mmGiveOrderToClient.afterGiveOrderToClientCounter, 1)

	mmGiveOrderToClient.t.Helper()

	if mmGiveOrderToClient.inspectFuncGiveOrderToClient != nil {
		mmGiveOrderToClient.inspectFuncGiveOrderToClient(ctx, orderIDs)
	}

	mm_params := IPVZOrderUseCaseMockGiveOrderToClientParams{ctx, orderIDs}

	// Record call args
	mmGiveOrderToClient.GiveOrderToClientMock.mutex.Lock()
	mmGiveOrderToClient.GiveOrderToClientMock.callArgs = append(mmGiveOrderToClient.GiveOrderToClientMock.callArgs, &mm_params)
	mmGiveOrderToClient.GiveOrderToClientMock.mutex.Unlock()

	for _, e := range mmGiveOrderToClient.GiveOrderToClientMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGiveOrderToClient.GiveOrderToClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGiveOrderToClient.GiveOrderToClientMock.defaultExpectation.Counter, 1)
		mm_want := mmGiveOrderToClient.GiveOrderToClientMock.defaultExpectation.params
		mm_want_ptrs := mmGiveOrderToClient.GiveOrderToClientMock.defaultExpectation.paramPtrs

		mm_got := IPVZOrderUseCaseMockGiveOrderToClientParams{ctx, orderIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGiveOrderToClient.t.Errorf("IPVZOrderUseCaseMock.GiveOrderToClient got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGiveOrderToClient.GiveOrderToClientMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderIDs != nil && !minimock.Equal(*mm_want_ptrs.orderIDs, mm_got.orderIDs) {
				mmGiveOrderToClient.t.Errorf("IPVZOrderUseCaseMock.GiveOrderToClient got unexpected parameter orderIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGiveOrderToClient.GiveOrderToClientMock.defaultExpectation.expectationOrigins.originOrderIDs, *mm_want_ptrs.orderIDs, mm_got.orderIDs, minimock.Diff(*mm_want_ptrs.orderIDs, mm_got.orderIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGiveOrderToClient.t.Errorf("IPVZOrderUseCaseMock.GiveOrderToClient got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGiveOrderToClient.GiveOrderToClientMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGiveOrderToClient.GiveOrderToClientMock.defaultExpectation.results
		if mm_results == nil {
			mmGiveOrderToClient.t.Fatal("No results are set for the IPVZOrderUseCaseMock.GiveOrderToClient")
		}
		return (*mm_results).err
	}
	if mmGiveOrderToClient.funcGiveOrderToClient != nil {
		return mmGiveOrderToClient.funcGiveOrderToClient(ctx, orderIDs)
	}
	mmGiveOrderToClient.t.Fatalf("Unexpected call to IPVZOrderUseCaseMock.GiveOrderToClient. %v %v", ctx, orderIDs)
	return
}

// GiveOrderToClientAfterCounter returns a count of finished IPVZOrderUseCaseMock.GiveOrderToClient invocations
func (mmGiveOrderToClient *IPVZOrderUseCaseMock) GiveOrderToClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveOrderToClient.afterGiveOrderToClientCounter)
}

// GiveOrderToClientBeforeCounter returns a count of IPVZOrderUseCaseMock.GiveOrderToClient invocations
func (mmGiveOrderToClient *IPVZOrderUseCaseMock) GiveOrderToClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveOrderToClient.beforeGiveOrderToClientCounter)
}

// Calls returns a list of arguments used in each call to IPVZOrderUseCaseMock.GiveOrderToClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGiveOrderToClient *mIPVZOrderUseCaseMockGiveOrderToClient) Calls() []*IPVZOrderUseCaseMockGiveOrderToClientParams {
	mmGiveOrderToClient.mutex.RLock()

	argCopy := make([]*IPVZOrderUseCaseMockGiveOrderToClientParams, len(mmGiveOrderToClient.callArgs))
	copy(argCopy, mmGiveOrderToClient.callArgs)

	mmGiveOrderToClient.mutex.RUnlock()

	return argCopy
}

// MinimockGiveOrderToClientDone returns true if the count of the GiveOrderToClient invocations corresponds
// the number of defined expectations
func (m *IPVZOrderUseCaseMock) MinimockGiveOrderToClientDone() bool {
	if m.GiveOrderToClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GiveOrderToClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GiveOrderToClientMock.invocationsDone()
}

// MinimockGiveOrderToClientInspect logs each unmet expectation
func (m *IPVZOrderUseCaseMock) MinimockGiveOrderToClientInspect() {
	for _, e := range m.GiveOrderToClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.GiveOrderToClient at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGiveOrderToClientCounter := mm_atomic.LoadUint64(&m.afterGiveOrderToClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GiveOrderToClientMock.defaultExpectation != nil && afterGiveOrderToClientCounter < 1 {
		if m.GiveOrderToClientMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.GiveOrderToClient at\n%s", m.GiveOrderToClientMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.GiveOrderToClient at\n%s with params: %#v", m.GiveOrderToClientMock.defaultExpectation.expectationOrigins.origin, *m.GiveOrderToClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGiveOrderToClient != nil && afterGiveOrderToClientCounter < 1 {
		m.t.Errorf("Expected call to IPVZOrderUseCaseMock.GiveOrderToClient at\n%s", m.funcGiveOrderToClientOrigin)
	}

	if !m.GiveOrderToClientMock.invocationsDone() && afterGiveOrderToClientCounter > 0 {
		m.t.Errorf("Expected %d calls to IPVZOrderUseCaseMock.GiveOrderToClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GiveOrderToClientMock.expectedInvocations), m.GiveOrderToClientMock.expectedInvocationsOrigin, afterGiveOrderToClientCounter)
	}
}

type mIPVZOrderUseCaseMockReturnOrderDelivery struct {
	optional           bool
	mock               *IPVZOrderUseCaseMock
	defaultExpectation *IPVZOrderUseCaseMockReturnOrderDeliveryExpectation
	expectations       []*IPVZOrderUseCaseMockReturnOrderDeliveryExpectation

	callArgs []*IPVZOrderUseCaseMockReturnOrderDeliveryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IPVZOrderUseCaseMockReturnOrderDeliveryExpectation specifies expectation struct of the IPVZOrderUseCase.ReturnOrderDelivery
type IPVZOrderUseCaseMockReturnOrderDeliveryExpectation struct {
	mock               *IPVZOrderUseCaseMock
	params             *IPVZOrderUseCaseMockReturnOrderDeliveryParams
	paramPtrs          *IPVZOrderUseCaseMockReturnOrderDeliveryParamPtrs
	expectationOrigins IPVZOrderUseCaseMockReturnOrderDeliveryExpectationOrigins
	results            *IPVZOrderUseCaseMockReturnOrderDeliveryResults
	returnOrigin       string
	Counter            uint64
}

// IPVZOrderUseCaseMockReturnOrderDeliveryParams contains parameters of the IPVZOrderUseCase.ReturnOrderDelivery
type IPVZOrderUseCaseMockReturnOrderDeliveryParams struct {
	ctx     context.Context
	orderID string
}

// IPVZOrderUseCaseMockReturnOrderDeliveryParamPtrs contains pointers to parameters of the IPVZOrderUseCase.ReturnOrderDelivery
type IPVZOrderUseCaseMockReturnOrderDeliveryParamPtrs struct {
	ctx     *context.Context
	orderID *string
}

// IPVZOrderUseCaseMockReturnOrderDeliveryResults contains results of the IPVZOrderUseCase.ReturnOrderDelivery
type IPVZOrderUseCaseMockReturnOrderDeliveryResults struct {
	err error
}

// IPVZOrderUseCaseMockReturnOrderDeliveryOrigins contains origins of expectations of the IPVZOrderUseCase.ReturnOrderDelivery
type IPVZOrderUseCaseMockReturnOrderDeliveryExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReturnOrderDelivery *mIPVZOrderUseCaseMockReturnOrderDelivery) Optional() *mIPVZOrderUseCaseMockReturnOrderDelivery {
	mmReturnOrderDelivery.optional = true
	return mmReturnOrderDelivery
}

// Expect sets up expected params for IPVZOrderUseCase.ReturnOrderDelivery
func (mmReturnOrderDelivery *mIPVZOrderUseCaseMockReturnOrderDelivery) Expect(ctx context.Context, orderID string) *mIPVZOrderUseCaseMockReturnOrderDelivery {
	if mmReturnOrderDelivery.mock.funcReturnOrderDelivery != nil {
		mmReturnOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.ReturnOrderDelivery mock is already set by Set")
	}

	if mmReturnOrderDelivery.defaultExpectation == nil {
		mmReturnOrderDelivery.defaultExpectation = &IPVZOrderUseCaseMockReturnOrderDeliveryExpectation{}
	}

	if mmReturnOrderDelivery.defaultExpectation.paramPtrs != nil {
		mmReturnOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.ReturnOrderDelivery mock is already set by ExpectParams functions")
	}

	mmReturnOrderDelivery.defaultExpectation.params = &IPVZOrderUseCaseMockReturnOrderDeliveryParams{ctx, orderID}
	mmReturnOrderDelivery.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReturnOrderDelivery.expectations {
		if minimock.Equal(e.params, mmReturnOrderDelivery.defaultExpectation.params) {
			mmReturnOrderDelivery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReturnOrderDelivery.defaultExpectation.params)
		}
	}

	return mmReturnOrderDelivery
}

// ExpectCtxParam1 sets up expected param ctx for IPVZOrderUseCase.ReturnOrderDelivery
func (mmReturnOrderDelivery *mIPVZOrderUseCaseMockReturnOrderDelivery) ExpectCtxParam1(ctx context.Context) *mIPVZOrderUseCaseMockReturnOrderDelivery {
	if mmReturnOrderDelivery.mock.funcReturnOrderDelivery != nil {
		mmReturnOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.ReturnOrderDelivery mock is already set by Set")
	}

	if mmReturnOrderDelivery.defaultExpectation == nil {
		mmReturnOrderDelivery.defaultExpectation = &IPVZOrderUseCaseMockReturnOrderDeliveryExpectation{}
	}

	if mmReturnOrderDelivery.defaultExpectation.params != nil {
		mmReturnOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.ReturnOrderDelivery mock is already set by Expect")
	}

	if mmReturnOrderDelivery.defaultExpectation.paramPtrs == nil {
		mmReturnOrderDelivery.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockReturnOrderDeliveryParamPtrs{}
	}
	mmReturnOrderDelivery.defaultExpectation.paramPtrs.ctx = &ctx
	mmReturnOrderDelivery.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReturnOrderDelivery
}

// ExpectOrderIDParam2 sets up expected param orderID for IPVZOrderUseCase.ReturnOrderDelivery
func (mmReturnOrderDelivery *mIPVZOrderUseCaseMockReturnOrderDelivery) ExpectOrderIDParam2(orderID string) *mIPVZOrderUseCaseMockReturnOrderDelivery {
	if mmReturnOrderDelivery.mock.funcReturnOrderDelivery != nil {
		mmReturnOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.ReturnOrderDelivery mock is already set by Set")
	}

	if mmReturnOrderDelivery.defaultExpectation == nil {
		mmReturnOrderDelivery.defaultExpectation = &IPVZOrderUseCaseMockReturnOrderDeliveryExpectation{}
	}

	if mmReturnOrderDelivery.defaultExpectation.params != nil {
		mmReturnOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.ReturnOrderDelivery mock is already set by Expect")
	}

	if mmReturnOrderDelivery.defaultExpectation.paramPtrs == nil {
		mmReturnOrderDelivery.defaultExpectation.paramPtrs = &IPVZOrderUseCaseMockReturnOrderDeliveryParamPtrs{}
	}
	mmReturnOrderDelivery.defaultExpectation.paramPtrs.orderID = &orderID
	mmReturnOrderDelivery.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmReturnOrderDelivery
}

// Inspect accepts an inspector function that has same arguments as the IPVZOrderUseCase.ReturnOrderDelivery
func (mmReturnOrderDelivery *mIPVZOrderUseCaseMockReturnOrderDelivery) Inspect(f func(ctx context.Context, orderID string)) *mIPVZOrderUseCaseMockReturnOrderDelivery {
	if mmReturnOrderDelivery.mock.inspectFuncReturnOrderDelivery != nil {
		mmReturnOrderDelivery.mock.t.Fatalf("Inspect function is already set for IPVZOrderUseCaseMock.ReturnOrderDelivery")
	}

	mmReturnOrderDelivery.mock.inspectFuncReturnOrderDelivery = f

	return mmReturnOrderDelivery
}

// Return sets up results that will be returned by IPVZOrderUseCase.ReturnOrderDelivery
func (mmReturnOrderDelivery *mIPVZOrderUseCaseMockReturnOrderDelivery) Return(err error) *IPVZOrderUseCaseMock {
	if mmReturnOrderDelivery.mock.funcReturnOrderDelivery != nil {
		mmReturnOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.ReturnOrderDelivery mock is already set by Set")
	}

	if mmReturnOrderDelivery.defaultExpectation == nil {
		mmReturnOrderDelivery.defaultExpectation = &IPVZOrderUseCaseMockReturnOrderDeliveryExpectation{mock: mmReturnOrderDelivery.mock}
	}
	mmReturnOrderDelivery.defaultExpectation.results = &IPVZOrderUseCaseMockReturnOrderDeliveryResults{err}
	mmReturnOrderDelivery.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReturnOrderDelivery.mock
}

// Set uses given function f to mock the IPVZOrderUseCase.ReturnOrderDelivery method
func (mmReturnOrderDelivery *mIPVZOrderUseCaseMockReturnOrderDelivery) Set(f func(ctx context.Context, orderID string) (err error)) *IPVZOrderUseCaseMock {
	if mmReturnOrderDelivery.defaultExpectation != nil {
		mmReturnOrderDelivery.mock.t.Fatalf("Default expectation is already set for the IPVZOrderUseCase.ReturnOrderDelivery method")
	}

	if len(mmReturnOrderDelivery.expectations) > 0 {
		mmReturnOrderDelivery.mock.t.Fatalf("Some expectations are already set for the IPVZOrderUseCase.ReturnOrderDelivery method")
	}

	mmReturnOrderDelivery.mock.funcReturnOrderDelivery = f
	mmReturnOrderDelivery.mock.funcReturnOrderDeliveryOrigin = minimock.CallerInfo(1)
	return mmReturnOrderDelivery.mock
}

// When sets expectation for the IPVZOrderUseCase.ReturnOrderDelivery which will trigger the result defined by the following
// Then helper
func (mmReturnOrderDelivery *mIPVZOrderUseCaseMockReturnOrderDelivery) When(ctx context.Context, orderID string) *IPVZOrderUseCaseMockReturnOrderDeliveryExpectation {
	if mmReturnOrderDelivery.mock.funcReturnOrderDelivery != nil {
		mmReturnOrderDelivery.mock.t.Fatalf("IPVZOrderUseCaseMock.ReturnOrderDelivery mock is already set by Set")
	}

	expectation := &IPVZOrderUseCaseMockReturnOrderDeliveryExpectation{
		mock:               mmReturnOrderDelivery.mock,
		params:             &IPVZOrderUseCaseMockReturnOrderDeliveryParams{ctx, orderID},
		expectationOrigins: IPVZOrderUseCaseMockReturnOrderDeliveryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReturnOrderDelivery.expectations = append(mmReturnOrderDelivery.expectations, expectation)
	return expectation
}

// Then sets up IPVZOrderUseCase.ReturnOrderDelivery return parameters for the expectation previously defined by the When method
func (e *IPVZOrderUseCaseMockReturnOrderDeliveryExpectation) Then(err error) *IPVZOrderUseCaseMock {
	e.results = &IPVZOrderUseCaseMockReturnOrderDeliveryResults{err}
	return e.mock
}

// Times sets number of times IPVZOrderUseCase.ReturnOrderDelivery should be invoked
func (mmReturnOrderDelivery *mIPVZOrderUseCaseMockReturnOrderDelivery) Times(n uint64) *mIPVZOrderUseCaseMockReturnOrderDelivery {
	if n == 0 {
		mmReturnOrderDelivery.mock.t.Fatalf("Times of IPVZOrderUseCaseMock.ReturnOrderDelivery mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReturnOrderDelivery.expectedInvocations, n)
	mmReturnOrderDelivery.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReturnOrderDelivery
}

func (mmReturnOrderDelivery *mIPVZOrderUseCaseMockReturnOrderDelivery) invocationsDone() bool {
	if len(mmReturnOrderDelivery.expectations) == 0 && mmReturnOrderDelivery.defaultExpectation == nil && mmReturnOrderDelivery.mock.funcReturnOrderDelivery == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReturnOrderDelivery.mock.afterReturnOrderDeliveryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReturnOrderDelivery.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReturnOrderDelivery implements mm_abstractions.IPVZOrderUseCase
func (mmReturnOrderDelivery *IPVZOrderUseCaseMock) ReturnOrderDelivery(ctx context.Context, orderID string) (err error) {
	mm_atomic.AddUint64(&mmReturnOrderDelivery.beforeReturnOrderDeliveryCounter, 1)
	defer mm_atomic.AddUint64(&mmReturnOrderDelivery.afterReturnOrderDeliveryCounter, 1)

	mmReturnOrderDelivery.t.Helper()

	if mmReturnOrderDelivery.inspectFuncReturnOrderDelivery != nil {
		mmReturnOrderDelivery.inspectFuncReturnOrderDelivery(ctx, orderID)
	}

	mm_params := IPVZOrderUseCaseMockReturnOrderDeliveryParams{ctx, orderID}

	// Record call args
	mmReturnOrderDelivery.ReturnOrderDeliveryMock.mutex.Lock()
	mmReturnOrderDelivery.ReturnOrderDeliveryMock.callArgs = append(mmReturnOrderDelivery.ReturnOrderDeliveryMock.callArgs, &mm_params)
	mmReturnOrderDelivery.ReturnOrderDeliveryMock.mutex.Unlock()

	for _, e := range mmReturnOrderDelivery.ReturnOrderDeliveryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReturnOrderDelivery.ReturnOrderDeliveryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReturnOrderDelivery.ReturnOrderDeliveryMock.defaultExpectation.Counter, 1)
		mm_want := mmReturnOrderDelivery.ReturnOrderDeliveryMock.defaultExpectation.params
		mm_want_ptrs := mmReturnOrderDelivery.ReturnOrderDeliveryMock.defaultExpectation.paramPtrs

		mm_got := IPVZOrderUseCaseMockReturnOrderDeliveryParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReturnOrderDelivery.t.Errorf("IPVZOrderUseCaseMock.ReturnOrderDelivery got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReturnOrderDelivery.ReturnOrderDeliveryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmReturnOrderDelivery.t.Errorf("IPVZOrderUseCaseMock.ReturnOrderDelivery got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReturnOrderDelivery.ReturnOrderDeliveryMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReturnOrderDelivery.t.Errorf("IPVZOrderUseCaseMock.ReturnOrderDelivery got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReturnOrderDelivery.ReturnOrderDeliveryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReturnOrderDelivery.ReturnOrderDeliveryMock.defaultExpectation.results
		if mm_results == nil {
			mmReturnOrderDelivery.t.Fatal("No results are set for the IPVZOrderUseCaseMock.ReturnOrderDelivery")
		}
		return (*mm_results).err
	}
	if mmReturnOrderDelivery.funcReturnOrderDelivery != nil {
		return mmReturnOrderDelivery.funcReturnOrderDelivery(ctx, orderID)
	}
	mmReturnOrderDelivery.t.Fatalf("Unexpected call to IPVZOrderUseCaseMock.ReturnOrderDelivery. %v %v", ctx, orderID)
	return
}

// ReturnOrderDeliveryAfterCounter returns a count of finished IPVZOrderUseCaseMock.ReturnOrderDelivery invocations
func (mmReturnOrderDelivery *IPVZOrderUseCaseMock) ReturnOrderDeliveryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnOrderDelivery.afterReturnOrderDeliveryCounter)
}

// ReturnOrderDeliveryBeforeCounter returns a count of IPVZOrderUseCaseMock.ReturnOrderDelivery invocations
func (mmReturnOrderDelivery *IPVZOrderUseCaseMock) ReturnOrderDeliveryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnOrderDelivery.beforeReturnOrderDeliveryCounter)
}

// Calls returns a list of arguments used in each call to IPVZOrderUseCaseMock.ReturnOrderDelivery.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReturnOrderDelivery *mIPVZOrderUseCaseMockReturnOrderDelivery) Calls() []*IPVZOrderUseCaseMockReturnOrderDeliveryParams {
	mmReturnOrderDelivery.mutex.RLock()

	argCopy := make([]*IPVZOrderUseCaseMockReturnOrderDeliveryParams, len(mmReturnOrderDelivery.callArgs))
	copy(argCopy, mmReturnOrderDelivery.callArgs)

	mmReturnOrderDelivery.mutex.RUnlock()

	return argCopy
}

// MinimockReturnOrderDeliveryDone returns true if the count of the ReturnOrderDelivery invocations corresponds
// the number of defined expectations
func (m *IPVZOrderUseCaseMock) MinimockReturnOrderDeliveryDone() bool {
	if m.ReturnOrderDeliveryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReturnOrderDeliveryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReturnOrderDeliveryMock.invocationsDone()
}

// MinimockReturnOrderDeliveryInspect logs each unmet expectation
func (m *IPVZOrderUseCaseMock) MinimockReturnOrderDeliveryInspect() {
	for _, e := range m.ReturnOrderDeliveryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.ReturnOrderDelivery at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReturnOrderDeliveryCounter := mm_atomic.LoadUint64(&m.afterReturnOrderDeliveryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReturnOrderDeliveryMock.defaultExpectation != nil && afterReturnOrderDeliveryCounter < 1 {
		if m.ReturnOrderDeliveryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.ReturnOrderDelivery at\n%s", m.ReturnOrderDeliveryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IPVZOrderUseCaseMock.ReturnOrderDelivery at\n%s with params: %#v", m.ReturnOrderDeliveryMock.defaultExpectation.expectationOrigins.origin, *m.ReturnOrderDeliveryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReturnOrderDelivery != nil && afterReturnOrderDeliveryCounter < 1 {
		m.t.Errorf("Expected call to IPVZOrderUseCaseMock.ReturnOrderDelivery at\n%s", m.funcReturnOrderDeliveryOrigin)
	}

	if !m.ReturnOrderDeliveryMock.invocationsDone() && afterReturnOrderDeliveryCounter > 0 {
		m.t.Errorf("Expected %d calls to IPVZOrderUseCaseMock.ReturnOrderDelivery at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReturnOrderDeliveryMock.expectedInvocations), m.ReturnOrderDeliveryMock.expectedInvocationsOrigin, afterReturnOrderDeliveryCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IPVZOrderUseCaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAcceptOrderDeliveryInspect()

			m.MinimockAcceptReturnInspect()

			m.MinimockGetOrdersInspect()

			m.MinimockGetReturnsInspect()

			m.MinimockGiveOrderToClientInspect()

			m.MinimockReturnOrderDeliveryInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IPVZOrderUseCaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IPVZOrderUseCaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAcceptOrderDeliveryDone() &&
		m.MinimockAcceptReturnDone() &&
		m.MinimockGetOrdersDone() &&
		m.MinimockGetReturnsDone() &&
		m.MinimockGiveOrderToClientDone() &&
		m.MinimockReturnOrderDeliveryDone()
}
