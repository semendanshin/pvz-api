// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

import (
	"context"
	"homework/internal/abstractions"
	"homework/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	_ "github.com/gojuno/minimock/v3"
)

// PVZOrderRepositoryMock implements mm_usecases.PVZOrderRepository
type PVZOrderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateOrder          func(ctx context.Context, order domain.PVZOrder) (err error)
	funcCreateOrderOrigin    string
	inspectFuncCreateOrder   func(ctx context.Context, order domain.PVZOrder)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mPVZOrderRepositoryMockCreateOrder

	funcDeleteOrder          func(ctx context.Context, orderID string) (err error)
	funcDeleteOrderOrigin    string
	inspectFuncDeleteOrder   func(ctx context.Context, orderID string)
	afterDeleteOrderCounter  uint64
	beforeDeleteOrderCounter uint64
	DeleteOrderMock          mPVZOrderRepositoryMockDeleteOrder

	funcGetOrder          func(ctx context.Context, orderID string) (p1 domain.PVZOrder, err error)
	funcGetOrderOrigin    string
	inspectFuncGetOrder   func(ctx context.Context, orderID string)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mPVZOrderRepositoryMockGetOrder

	funcGetOrders          func(ctx context.Context, userID string, options ...abstractions.GetOrdersOptFunc) (pa1 []domain.PVZOrder, err error)
	funcGetOrdersOrigin    string
	inspectFuncGetOrders   func(ctx context.Context, userID string, options ...abstractions.GetOrdersOptFunc)
	afterGetOrdersCounter  uint64
	beforeGetOrdersCounter uint64
	GetOrdersMock          mPVZOrderRepositoryMockGetOrders

	funcGetReturns          func(ctx context.Context, options ...abstractions.PagePaginationOptFunc) (pa1 []domain.PVZOrder, err error)
	funcGetReturnsOrigin    string
	inspectFuncGetReturns   func(ctx context.Context, options ...abstractions.PagePaginationOptFunc)
	afterGetReturnsCounter  uint64
	beforeGetReturnsCounter uint64
	GetReturnsMock          mPVZOrderRepositoryMockGetReturns

	funcSetOrderIssued          func(ctx context.Context, orderID string) (err error)
	funcSetOrderIssuedOrigin    string
	inspectFuncSetOrderIssued   func(ctx context.Context, orderID string)
	afterSetOrderIssuedCounter  uint64
	beforeSetOrderIssuedCounter uint64
	SetOrderIssuedMock          mPVZOrderRepositoryMockSetOrderIssued

	funcSetOrderReturned          func(ctx context.Context, orderID string) (err error)
	funcSetOrderReturnedOrigin    string
	inspectFuncSetOrderReturned   func(ctx context.Context, orderID string)
	afterSetOrderReturnedCounter  uint64
	beforeSetOrderReturnedCounter uint64
	SetOrderReturnedMock          mPVZOrderRepositoryMockSetOrderReturned
}

// NewPVZOrderRepositoryMock returns a mock for mm_usecases.PVZOrderRepository
func NewPVZOrderRepositoryMock(t minimock.Tester) *PVZOrderRepositoryMock {
	m := &PVZOrderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateOrderMock = mPVZOrderRepositoryMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*PVZOrderRepositoryMockCreateOrderParams{}

	m.DeleteOrderMock = mPVZOrderRepositoryMockDeleteOrder{mock: m}
	m.DeleteOrderMock.callArgs = []*PVZOrderRepositoryMockDeleteOrderParams{}

	m.GetOrderMock = mPVZOrderRepositoryMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*PVZOrderRepositoryMockGetOrderParams{}

	m.GetOrdersMock = mPVZOrderRepositoryMockGetOrders{mock: m}
	m.GetOrdersMock.callArgs = []*PVZOrderRepositoryMockGetOrdersParams{}

	m.GetReturnsMock = mPVZOrderRepositoryMockGetReturns{mock: m}
	m.GetReturnsMock.callArgs = []*PVZOrderRepositoryMockGetReturnsParams{}

	m.SetOrderIssuedMock = mPVZOrderRepositoryMockSetOrderIssued{mock: m}
	m.SetOrderIssuedMock.callArgs = []*PVZOrderRepositoryMockSetOrderIssuedParams{}

	m.SetOrderReturnedMock = mPVZOrderRepositoryMockSetOrderReturned{mock: m}
	m.SetOrderReturnedMock.callArgs = []*PVZOrderRepositoryMockSetOrderReturnedParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPVZOrderRepositoryMockCreateOrder struct {
	optional           bool
	mock               *PVZOrderRepositoryMock
	defaultExpectation *PVZOrderRepositoryMockCreateOrderExpectation
	expectations       []*PVZOrderRepositoryMockCreateOrderExpectation

	callArgs []*PVZOrderRepositoryMockCreateOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZOrderRepositoryMockCreateOrderExpectation specifies expectation struct of the PVZOrderRepository.CreateOrder
type PVZOrderRepositoryMockCreateOrderExpectation struct {
	mock               *PVZOrderRepositoryMock
	params             *PVZOrderRepositoryMockCreateOrderParams
	paramPtrs          *PVZOrderRepositoryMockCreateOrderParamPtrs
	expectationOrigins PVZOrderRepositoryMockCreateOrderExpectationOrigins
	results            *PVZOrderRepositoryMockCreateOrderResults
	returnOrigin       string
	Counter            uint64
}

// PVZOrderRepositoryMockCreateOrderParams contains parameters of the PVZOrderRepository.CreateOrder
type PVZOrderRepositoryMockCreateOrderParams struct {
	ctx   context.Context
	order domain.PVZOrder
}

// PVZOrderRepositoryMockCreateOrderParamPtrs contains pointers to parameters of the PVZOrderRepository.CreateOrder
type PVZOrderRepositoryMockCreateOrderParamPtrs struct {
	ctx   *context.Context
	order *domain.PVZOrder
}

// PVZOrderRepositoryMockCreateOrderResults contains results of the PVZOrderRepository.CreateOrder
type PVZOrderRepositoryMockCreateOrderResults struct {
	err error
}

// PVZOrderRepositoryMockCreateOrderOrigins contains origins of expectations of the PVZOrderRepository.CreateOrder
type PVZOrderRepositoryMockCreateOrderExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrder *mPVZOrderRepositoryMockCreateOrder) Optional() *mPVZOrderRepositoryMockCreateOrder {
	mmCreateOrder.optional = true
	return mmCreateOrder
}

// Expect sets up expected params for PVZOrderRepository.CreateOrder
func (mmCreateOrder *mPVZOrderRepositoryMockCreateOrder) Expect(ctx context.Context, order domain.PVZOrder) *mPVZOrderRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("PVZOrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &PVZOrderRepositoryMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.paramPtrs != nil {
		mmCreateOrder.mock.t.Fatalf("PVZOrderRepositoryMock.CreateOrder mock is already set by ExpectParams functions")
	}

	mmCreateOrder.defaultExpectation.params = &PVZOrderRepositoryMockCreateOrderParams{ctx, order}
	mmCreateOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// ExpectCtxParam1 sets up expected param ctx for PVZOrderRepository.CreateOrder
func (mmCreateOrder *mPVZOrderRepositoryMockCreateOrder) ExpectCtxParam1(ctx context.Context) *mPVZOrderRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("PVZOrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &PVZOrderRepositoryMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("PVZOrderRepositoryMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateOrder
}

// ExpectOrderParam2 sets up expected param order for PVZOrderRepository.CreateOrder
func (mmCreateOrder *mPVZOrderRepositoryMockCreateOrder) ExpectOrderParam2(order domain.PVZOrder) *mPVZOrderRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("PVZOrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &PVZOrderRepositoryMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("PVZOrderRepositoryMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.order = &order
	mmCreateOrder.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the PVZOrderRepository.CreateOrder
func (mmCreateOrder *mPVZOrderRepositoryMockCreateOrder) Inspect(f func(ctx context.Context, order domain.PVZOrder)) *mPVZOrderRepositoryMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for PVZOrderRepositoryMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by PVZOrderRepository.CreateOrder
func (mmCreateOrder *mPVZOrderRepositoryMockCreateOrder) Return(err error) *PVZOrderRepositoryMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("PVZOrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &PVZOrderRepositoryMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &PVZOrderRepositoryMockCreateOrderResults{err}
	mmCreateOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// Set uses given function f to mock the PVZOrderRepository.CreateOrder method
func (mmCreateOrder *mPVZOrderRepositoryMockCreateOrder) Set(f func(ctx context.Context, order domain.PVZOrder) (err error)) *PVZOrderRepositoryMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the PVZOrderRepository.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the PVZOrderRepository.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	mmCreateOrder.mock.funcCreateOrderOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// When sets expectation for the PVZOrderRepository.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mPVZOrderRepositoryMockCreateOrder) When(ctx context.Context, order domain.PVZOrder) *PVZOrderRepositoryMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("PVZOrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	expectation := &PVZOrderRepositoryMockCreateOrderExpectation{
		mock:               mmCreateOrder.mock,
		params:             &PVZOrderRepositoryMockCreateOrderParams{ctx, order},
		expectationOrigins: PVZOrderRepositoryMockCreateOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up PVZOrderRepository.CreateOrder return parameters for the expectation previously defined by the When method
func (e *PVZOrderRepositoryMockCreateOrderExpectation) Then(err error) *PVZOrderRepositoryMock {
	e.results = &PVZOrderRepositoryMockCreateOrderResults{err}
	return e.mock
}

// Times sets number of times PVZOrderRepository.CreateOrder should be invoked
func (mmCreateOrder *mPVZOrderRepositoryMockCreateOrder) Times(n uint64) *mPVZOrderRepositoryMockCreateOrder {
	if n == 0 {
		mmCreateOrder.mock.t.Fatalf("Times of PVZOrderRepositoryMock.CreateOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrder.expectedInvocations, n)
	mmCreateOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateOrder
}

func (mmCreateOrder *mPVZOrderRepositoryMockCreateOrder) invocationsDone() bool {
	if len(mmCreateOrder.expectations) == 0 && mmCreateOrder.defaultExpectation == nil && mmCreateOrder.mock.funcCreateOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrder.mock.afterCreateOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrder implements mm_usecases.PVZOrderRepository
func (mmCreateOrder *PVZOrderRepositoryMock) CreateOrder(ctx context.Context, order domain.PVZOrder) (err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	mmCreateOrder.t.Helper()

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, order)
	}

	mm_params := PVZOrderRepositoryMockCreateOrderParams{ctx, order}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrder.CreateOrderMock.defaultExpectation.paramPtrs

		mm_got := PVZOrderRepositoryMockCreateOrderParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateOrder.t.Errorf("PVZOrderRepositoryMock.CreateOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmCreateOrder.t.Errorf("PVZOrderRepositoryMock.CreateOrder got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("PVZOrderRepositoryMock.CreateOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the PVZOrderRepositoryMock.CreateOrder")
		}
		return (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, order)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to PVZOrderRepositoryMock.CreateOrder. %v %v", ctx, order)
	return
}

// CreateOrderAfterCounter returns a count of finished PVZOrderRepositoryMock.CreateOrder invocations
func (mmCreateOrder *PVZOrderRepositoryMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of PVZOrderRepositoryMock.CreateOrder invocations
func (mmCreateOrder *PVZOrderRepositoryMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to PVZOrderRepositoryMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mPVZOrderRepositoryMockCreateOrder) Calls() []*PVZOrderRepositoryMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*PVZOrderRepositoryMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *PVZOrderRepositoryMock) MinimockCreateOrderDone() bool {
	if m.CreateOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrderMock.invocationsDone()
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *PVZOrderRepositoryMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.CreateOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateOrderCounter := mm_atomic.LoadUint64(&m.afterCreateOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && afterCreateOrderCounter < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.CreateOrder at\n%s", m.CreateOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.CreateOrder at\n%s with params: %#v", m.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && afterCreateOrderCounter < 1 {
		m.t.Errorf("Expected call to PVZOrderRepositoryMock.CreateOrder at\n%s", m.funcCreateOrderOrigin)
	}

	if !m.CreateOrderMock.invocationsDone() && afterCreateOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZOrderRepositoryMock.CreateOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrderMock.expectedInvocations), m.CreateOrderMock.expectedInvocationsOrigin, afterCreateOrderCounter)
	}
}

type mPVZOrderRepositoryMockDeleteOrder struct {
	optional           bool
	mock               *PVZOrderRepositoryMock
	defaultExpectation *PVZOrderRepositoryMockDeleteOrderExpectation
	expectations       []*PVZOrderRepositoryMockDeleteOrderExpectation

	callArgs []*PVZOrderRepositoryMockDeleteOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZOrderRepositoryMockDeleteOrderExpectation specifies expectation struct of the PVZOrderRepository.DeleteOrder
type PVZOrderRepositoryMockDeleteOrderExpectation struct {
	mock               *PVZOrderRepositoryMock
	params             *PVZOrderRepositoryMockDeleteOrderParams
	paramPtrs          *PVZOrderRepositoryMockDeleteOrderParamPtrs
	expectationOrigins PVZOrderRepositoryMockDeleteOrderExpectationOrigins
	results            *PVZOrderRepositoryMockDeleteOrderResults
	returnOrigin       string
	Counter            uint64
}

// PVZOrderRepositoryMockDeleteOrderParams contains parameters of the PVZOrderRepository.DeleteOrder
type PVZOrderRepositoryMockDeleteOrderParams struct {
	ctx     context.Context
	orderID string
}

// PVZOrderRepositoryMockDeleteOrderParamPtrs contains pointers to parameters of the PVZOrderRepository.DeleteOrder
type PVZOrderRepositoryMockDeleteOrderParamPtrs struct {
	ctx     *context.Context
	orderID *string
}

// PVZOrderRepositoryMockDeleteOrderResults contains results of the PVZOrderRepository.DeleteOrder
type PVZOrderRepositoryMockDeleteOrderResults struct {
	err error
}

// PVZOrderRepositoryMockDeleteOrderOrigins contains origins of expectations of the PVZOrderRepository.DeleteOrder
type PVZOrderRepositoryMockDeleteOrderExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteOrder *mPVZOrderRepositoryMockDeleteOrder) Optional() *mPVZOrderRepositoryMockDeleteOrder {
	mmDeleteOrder.optional = true
	return mmDeleteOrder
}

// Expect sets up expected params for PVZOrderRepository.DeleteOrder
func (mmDeleteOrder *mPVZOrderRepositoryMockDeleteOrder) Expect(ctx context.Context, orderID string) *mPVZOrderRepositoryMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("PVZOrderRepositoryMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &PVZOrderRepositoryMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs != nil {
		mmDeleteOrder.mock.t.Fatalf("PVZOrderRepositoryMock.DeleteOrder mock is already set by ExpectParams functions")
	}

	mmDeleteOrder.defaultExpectation.params = &PVZOrderRepositoryMockDeleteOrderParams{ctx, orderID}
	mmDeleteOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteOrder.expectations {
		if minimock.Equal(e.params, mmDeleteOrder.defaultExpectation.params) {
			mmDeleteOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrder.defaultExpectation.params)
		}
	}

	return mmDeleteOrder
}

// ExpectCtxParam1 sets up expected param ctx for PVZOrderRepository.DeleteOrder
func (mmDeleteOrder *mPVZOrderRepositoryMockDeleteOrder) ExpectCtxParam1(ctx context.Context) *mPVZOrderRepositoryMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("PVZOrderRepositoryMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &PVZOrderRepositoryMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.params != nil {
		mmDeleteOrder.mock.t.Fatalf("PVZOrderRepositoryMock.DeleteOrder mock is already set by Expect")
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs == nil {
		mmDeleteOrder.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockDeleteOrderParamPtrs{}
	}
	mmDeleteOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for PVZOrderRepository.DeleteOrder
func (mmDeleteOrder *mPVZOrderRepositoryMockDeleteOrder) ExpectOrderIDParam2(orderID string) *mPVZOrderRepositoryMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("PVZOrderRepositoryMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &PVZOrderRepositoryMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.params != nil {
		mmDeleteOrder.mock.t.Fatalf("PVZOrderRepositoryMock.DeleteOrder mock is already set by Expect")
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs == nil {
		mmDeleteOrder.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockDeleteOrderParamPtrs{}
	}
	mmDeleteOrder.defaultExpectation.paramPtrs.orderID = &orderID
	mmDeleteOrder.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmDeleteOrder
}

// Inspect accepts an inspector function that has same arguments as the PVZOrderRepository.DeleteOrder
func (mmDeleteOrder *mPVZOrderRepositoryMockDeleteOrder) Inspect(f func(ctx context.Context, orderID string)) *mPVZOrderRepositoryMockDeleteOrder {
	if mmDeleteOrder.mock.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Inspect function is already set for PVZOrderRepositoryMock.DeleteOrder")
	}

	mmDeleteOrder.mock.inspectFuncDeleteOrder = f

	return mmDeleteOrder
}

// Return sets up results that will be returned by PVZOrderRepository.DeleteOrder
func (mmDeleteOrder *mPVZOrderRepositoryMockDeleteOrder) Return(err error) *PVZOrderRepositoryMock {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("PVZOrderRepositoryMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &PVZOrderRepositoryMockDeleteOrderExpectation{mock: mmDeleteOrder.mock}
	}
	mmDeleteOrder.defaultExpectation.results = &PVZOrderRepositoryMockDeleteOrderResults{err}
	mmDeleteOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder.mock
}

// Set uses given function f to mock the PVZOrderRepository.DeleteOrder method
func (mmDeleteOrder *mPVZOrderRepositoryMockDeleteOrder) Set(f func(ctx context.Context, orderID string) (err error)) *PVZOrderRepositoryMock {
	if mmDeleteOrder.defaultExpectation != nil {
		mmDeleteOrder.mock.t.Fatalf("Default expectation is already set for the PVZOrderRepository.DeleteOrder method")
	}

	if len(mmDeleteOrder.expectations) > 0 {
		mmDeleteOrder.mock.t.Fatalf("Some expectations are already set for the PVZOrderRepository.DeleteOrder method")
	}

	mmDeleteOrder.mock.funcDeleteOrder = f
	mmDeleteOrder.mock.funcDeleteOrderOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder.mock
}

// When sets expectation for the PVZOrderRepository.DeleteOrder which will trigger the result defined by the following
// Then helper
func (mmDeleteOrder *mPVZOrderRepositoryMockDeleteOrder) When(ctx context.Context, orderID string) *PVZOrderRepositoryMockDeleteOrderExpectation {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("PVZOrderRepositoryMock.DeleteOrder mock is already set by Set")
	}

	expectation := &PVZOrderRepositoryMockDeleteOrderExpectation{
		mock:               mmDeleteOrder.mock,
		params:             &PVZOrderRepositoryMockDeleteOrderParams{ctx, orderID},
		expectationOrigins: PVZOrderRepositoryMockDeleteOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteOrder.expectations = append(mmDeleteOrder.expectations, expectation)
	return expectation
}

// Then sets up PVZOrderRepository.DeleteOrder return parameters for the expectation previously defined by the When method
func (e *PVZOrderRepositoryMockDeleteOrderExpectation) Then(err error) *PVZOrderRepositoryMock {
	e.results = &PVZOrderRepositoryMockDeleteOrderResults{err}
	return e.mock
}

// Times sets number of times PVZOrderRepository.DeleteOrder should be invoked
func (mmDeleteOrder *mPVZOrderRepositoryMockDeleteOrder) Times(n uint64) *mPVZOrderRepositoryMockDeleteOrder {
	if n == 0 {
		mmDeleteOrder.mock.t.Fatalf("Times of PVZOrderRepositoryMock.DeleteOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteOrder.expectedInvocations, n)
	mmDeleteOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder
}

func (mmDeleteOrder *mPVZOrderRepositoryMockDeleteOrder) invocationsDone() bool {
	if len(mmDeleteOrder.expectations) == 0 && mmDeleteOrder.defaultExpectation == nil && mmDeleteOrder.mock.funcDeleteOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteOrder.mock.afterDeleteOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteOrder implements mm_usecases.PVZOrderRepository
func (mmDeleteOrder *PVZOrderRepositoryMock) DeleteOrder(ctx context.Context, orderID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteOrder.beforeDeleteOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOrder.afterDeleteOrderCounter, 1)

	mmDeleteOrder.t.Helper()

	if mmDeleteOrder.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.inspectFuncDeleteOrder(ctx, orderID)
	}

	mm_params := PVZOrderRepositoryMockDeleteOrderParams{ctx, orderID}

	// Record call args
	mmDeleteOrder.DeleteOrderMock.mutex.Lock()
	mmDeleteOrder.DeleteOrderMock.callArgs = append(mmDeleteOrder.DeleteOrderMock.callArgs, &mm_params)
	mmDeleteOrder.DeleteOrderMock.mutex.Unlock()

	for _, e := range mmDeleteOrder.DeleteOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteOrder.DeleteOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOrder.DeleteOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOrder.DeleteOrderMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteOrder.DeleteOrderMock.defaultExpectation.paramPtrs

		mm_got := PVZOrderRepositoryMockDeleteOrderParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteOrder.t.Errorf("PVZOrderRepositoryMock.DeleteOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmDeleteOrder.t.Errorf("PVZOrderRepositoryMock.DeleteOrder got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOrder.t.Errorf("PVZOrderRepositoryMock.DeleteOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteOrder.DeleteOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteOrder.t.Fatal("No results are set for the PVZOrderRepositoryMock.DeleteOrder")
		}
		return (*mm_results).err
	}
	if mmDeleteOrder.funcDeleteOrder != nil {
		return mmDeleteOrder.funcDeleteOrder(ctx, orderID)
	}
	mmDeleteOrder.t.Fatalf("Unexpected call to PVZOrderRepositoryMock.DeleteOrder. %v %v", ctx, orderID)
	return
}

// DeleteOrderAfterCounter returns a count of finished PVZOrderRepositoryMock.DeleteOrder invocations
func (mmDeleteOrder *PVZOrderRepositoryMock) DeleteOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.afterDeleteOrderCounter)
}

// DeleteOrderBeforeCounter returns a count of PVZOrderRepositoryMock.DeleteOrder invocations
func (mmDeleteOrder *PVZOrderRepositoryMock) DeleteOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.beforeDeleteOrderCounter)
}

// Calls returns a list of arguments used in each call to PVZOrderRepositoryMock.DeleteOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrder *mPVZOrderRepositoryMockDeleteOrder) Calls() []*PVZOrderRepositoryMockDeleteOrderParams {
	mmDeleteOrder.mutex.RLock()

	argCopy := make([]*PVZOrderRepositoryMockDeleteOrderParams, len(mmDeleteOrder.callArgs))
	copy(argCopy, mmDeleteOrder.callArgs)

	mmDeleteOrder.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOrderDone returns true if the count of the DeleteOrder invocations corresponds
// the number of defined expectations
func (m *PVZOrderRepositoryMock) MinimockDeleteOrderDone() bool {
	if m.DeleteOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteOrderMock.invocationsDone()
}

// MinimockDeleteOrderInspect logs each unmet expectation
func (m *PVZOrderRepositoryMock) MinimockDeleteOrderInspect() {
	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.DeleteOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteOrderCounter := mm_atomic.LoadUint64(&m.afterDeleteOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderMock.defaultExpectation != nil && afterDeleteOrderCounter < 1 {
		if m.DeleteOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.DeleteOrder at\n%s", m.DeleteOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.DeleteOrder at\n%s with params: %#v", m.DeleteOrderMock.defaultExpectation.expectationOrigins.origin, *m.DeleteOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrder != nil && afterDeleteOrderCounter < 1 {
		m.t.Errorf("Expected call to PVZOrderRepositoryMock.DeleteOrder at\n%s", m.funcDeleteOrderOrigin)
	}

	if !m.DeleteOrderMock.invocationsDone() && afterDeleteOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZOrderRepositoryMock.DeleteOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteOrderMock.expectedInvocations), m.DeleteOrderMock.expectedInvocationsOrigin, afterDeleteOrderCounter)
	}
}

type mPVZOrderRepositoryMockGetOrder struct {
	optional           bool
	mock               *PVZOrderRepositoryMock
	defaultExpectation *PVZOrderRepositoryMockGetOrderExpectation
	expectations       []*PVZOrderRepositoryMockGetOrderExpectation

	callArgs []*PVZOrderRepositoryMockGetOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZOrderRepositoryMockGetOrderExpectation specifies expectation struct of the PVZOrderRepository.GetOrder
type PVZOrderRepositoryMockGetOrderExpectation struct {
	mock               *PVZOrderRepositoryMock
	params             *PVZOrderRepositoryMockGetOrderParams
	paramPtrs          *PVZOrderRepositoryMockGetOrderParamPtrs
	expectationOrigins PVZOrderRepositoryMockGetOrderExpectationOrigins
	results            *PVZOrderRepositoryMockGetOrderResults
	returnOrigin       string
	Counter            uint64
}

// PVZOrderRepositoryMockGetOrderParams contains parameters of the PVZOrderRepository.GetOrder
type PVZOrderRepositoryMockGetOrderParams struct {
	ctx     context.Context
	orderID string
}

// PVZOrderRepositoryMockGetOrderParamPtrs contains pointers to parameters of the PVZOrderRepository.GetOrder
type PVZOrderRepositoryMockGetOrderParamPtrs struct {
	ctx     *context.Context
	orderID *string
}

// PVZOrderRepositoryMockGetOrderResults contains results of the PVZOrderRepository.GetOrder
type PVZOrderRepositoryMockGetOrderResults struct {
	p1  domain.PVZOrder
	err error
}

// PVZOrderRepositoryMockGetOrderOrigins contains origins of expectations of the PVZOrderRepository.GetOrder
type PVZOrderRepositoryMockGetOrderExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrder *mPVZOrderRepositoryMockGetOrder) Optional() *mPVZOrderRepositoryMockGetOrder {
	mmGetOrder.optional = true
	return mmGetOrder
}

// Expect sets up expected params for PVZOrderRepository.GetOrder
func (mmGetOrder *mPVZOrderRepositoryMockGetOrder) Expect(ctx context.Context, orderID string) *mPVZOrderRepositoryMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &PVZOrderRepositoryMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.paramPtrs != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrder mock is already set by ExpectParams functions")
	}

	mmGetOrder.defaultExpectation.params = &PVZOrderRepositoryMockGetOrderParams{ctx, orderID}
	mmGetOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// ExpectCtxParam1 sets up expected param ctx for PVZOrderRepository.GetOrder
func (mmGetOrder *mPVZOrderRepositoryMockGetOrder) ExpectCtxParam1(ctx context.Context) *mPVZOrderRepositoryMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &PVZOrderRepositoryMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for PVZOrderRepository.GetOrder
func (mmGetOrder *mPVZOrderRepositoryMockGetOrder) ExpectOrderIDParam2(orderID string) *mPVZOrderRepositoryMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &PVZOrderRepositoryMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetOrder.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the PVZOrderRepository.GetOrder
func (mmGetOrder *mPVZOrderRepositoryMockGetOrder) Inspect(f func(ctx context.Context, orderID string)) *mPVZOrderRepositoryMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for PVZOrderRepositoryMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by PVZOrderRepository.GetOrder
func (mmGetOrder *mPVZOrderRepositoryMockGetOrder) Return(p1 domain.PVZOrder, err error) *PVZOrderRepositoryMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &PVZOrderRepositoryMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &PVZOrderRepositoryMockGetOrderResults{p1, err}
	mmGetOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// Set uses given function f to mock the PVZOrderRepository.GetOrder method
func (mmGetOrder *mPVZOrderRepositoryMockGetOrder) Set(f func(ctx context.Context, orderID string) (p1 domain.PVZOrder, err error)) *PVZOrderRepositoryMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the PVZOrderRepository.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the PVZOrderRepository.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	mmGetOrder.mock.funcGetOrderOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// When sets expectation for the PVZOrderRepository.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mPVZOrderRepositoryMockGetOrder) When(ctx context.Context, orderID string) *PVZOrderRepositoryMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrder mock is already set by Set")
	}

	expectation := &PVZOrderRepositoryMockGetOrderExpectation{
		mock:               mmGetOrder.mock,
		params:             &PVZOrderRepositoryMockGetOrderParams{ctx, orderID},
		expectationOrigins: PVZOrderRepositoryMockGetOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up PVZOrderRepository.GetOrder return parameters for the expectation previously defined by the When method
func (e *PVZOrderRepositoryMockGetOrderExpectation) Then(p1 domain.PVZOrder, err error) *PVZOrderRepositoryMock {
	e.results = &PVZOrderRepositoryMockGetOrderResults{p1, err}
	return e.mock
}

// Times sets number of times PVZOrderRepository.GetOrder should be invoked
func (mmGetOrder *mPVZOrderRepositoryMockGetOrder) Times(n uint64) *mPVZOrderRepositoryMockGetOrder {
	if n == 0 {
		mmGetOrder.mock.t.Fatalf("Times of PVZOrderRepositoryMock.GetOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrder.expectedInvocations, n)
	mmGetOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrder
}

func (mmGetOrder *mPVZOrderRepositoryMockGetOrder) invocationsDone() bool {
	if len(mmGetOrder.expectations) == 0 && mmGetOrder.defaultExpectation == nil && mmGetOrder.mock.funcGetOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrder.mock.afterGetOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrder implements mm_usecases.PVZOrderRepository
func (mmGetOrder *PVZOrderRepositoryMock) GetOrder(ctx context.Context, orderID string) (p1 domain.PVZOrder, err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	mmGetOrder.t.Helper()

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(ctx, orderID)
	}

	mm_params := PVZOrderRepositoryMockGetOrderParams{ctx, orderID}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, &mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrder.GetOrderMock.defaultExpectation.paramPtrs

		mm_got := PVZOrderRepositoryMockGetOrderParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrder.t.Errorf("PVZOrderRepositoryMock.GetOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetOrder.t.Errorf("PVZOrderRepositoryMock.GetOrder got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("PVZOrderRepositoryMock.GetOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the PVZOrderRepositoryMock.GetOrder")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(ctx, orderID)
	}
	mmGetOrder.t.Fatalf("Unexpected call to PVZOrderRepositoryMock.GetOrder. %v %v", ctx, orderID)
	return
}

// GetOrderAfterCounter returns a count of finished PVZOrderRepositoryMock.GetOrder invocations
func (mmGetOrder *PVZOrderRepositoryMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of PVZOrderRepositoryMock.GetOrder invocations
func (mmGetOrder *PVZOrderRepositoryMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to PVZOrderRepositoryMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mPVZOrderRepositoryMockGetOrder) Calls() []*PVZOrderRepositoryMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*PVZOrderRepositoryMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *PVZOrderRepositoryMock) MinimockGetOrderDone() bool {
	if m.GetOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderMock.invocationsDone()
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *PVZOrderRepositoryMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.GetOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderCounter := mm_atomic.LoadUint64(&m.afterGetOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && afterGetOrderCounter < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.GetOrder at\n%s", m.GetOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.GetOrder at\n%s with params: %#v", m.GetOrderMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && afterGetOrderCounter < 1 {
		m.t.Errorf("Expected call to PVZOrderRepositoryMock.GetOrder at\n%s", m.funcGetOrderOrigin)
	}

	if !m.GetOrderMock.invocationsDone() && afterGetOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZOrderRepositoryMock.GetOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderMock.expectedInvocations), m.GetOrderMock.expectedInvocationsOrigin, afterGetOrderCounter)
	}
}

type mPVZOrderRepositoryMockGetOrders struct {
	optional           bool
	mock               *PVZOrderRepositoryMock
	defaultExpectation *PVZOrderRepositoryMockGetOrdersExpectation
	expectations       []*PVZOrderRepositoryMockGetOrdersExpectation

	callArgs []*PVZOrderRepositoryMockGetOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZOrderRepositoryMockGetOrdersExpectation specifies expectation struct of the PVZOrderRepository.GetOrders
type PVZOrderRepositoryMockGetOrdersExpectation struct {
	mock               *PVZOrderRepositoryMock
	params             *PVZOrderRepositoryMockGetOrdersParams
	paramPtrs          *PVZOrderRepositoryMockGetOrdersParamPtrs
	expectationOrigins PVZOrderRepositoryMockGetOrdersExpectationOrigins
	results            *PVZOrderRepositoryMockGetOrdersResults
	returnOrigin       string
	Counter            uint64
}

// PVZOrderRepositoryMockGetOrdersParams contains parameters of the PVZOrderRepository.GetOrders
type PVZOrderRepositoryMockGetOrdersParams struct {
	ctx     context.Context
	userID  string
	options []abstractions.GetOrdersOptFunc
}

// PVZOrderRepositoryMockGetOrdersParamPtrs contains pointers to parameters of the PVZOrderRepository.GetOrders
type PVZOrderRepositoryMockGetOrdersParamPtrs struct {
	ctx     *context.Context
	userID  *string
	options *[]abstractions.GetOrdersOptFunc
}

// PVZOrderRepositoryMockGetOrdersResults contains results of the PVZOrderRepository.GetOrders
type PVZOrderRepositoryMockGetOrdersResults struct {
	pa1 []domain.PVZOrder
	err error
}

// PVZOrderRepositoryMockGetOrdersOrigins contains origins of expectations of the PVZOrderRepository.GetOrders
type PVZOrderRepositoryMockGetOrdersExpectationOrigins struct {
	origin        string
	originCtx     string
	originUserID  string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrders *mPVZOrderRepositoryMockGetOrders) Optional() *mPVZOrderRepositoryMockGetOrders {
	mmGetOrders.optional = true
	return mmGetOrders
}

// Expect sets up expected params for PVZOrderRepository.GetOrders
func (mmGetOrders *mPVZOrderRepositoryMockGetOrders) Expect(ctx context.Context, userID string, options ...abstractions.GetOrdersOptFunc) *mPVZOrderRepositoryMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &PVZOrderRepositoryMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.paramPtrs != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrders mock is already set by ExpectParams functions")
	}

	mmGetOrders.defaultExpectation.params = &PVZOrderRepositoryMockGetOrdersParams{ctx, userID, options}
	mmGetOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrders.expectations {
		if minimock.Equal(e.params, mmGetOrders.defaultExpectation.params) {
			mmGetOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrders.defaultExpectation.params)
		}
	}

	return mmGetOrders
}

// ExpectCtxParam1 sets up expected param ctx for PVZOrderRepository.GetOrders
func (mmGetOrders *mPVZOrderRepositoryMockGetOrders) ExpectCtxParam1(ctx context.Context) *mPVZOrderRepositoryMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &PVZOrderRepositoryMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrders
}

// ExpectUserIDParam2 sets up expected param userID for PVZOrderRepository.GetOrders
func (mmGetOrders *mPVZOrderRepositoryMockGetOrders) ExpectUserIDParam2(userID string) *mPVZOrderRepositoryMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &PVZOrderRepositoryMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.userID = &userID
	mmGetOrders.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetOrders
}

// ExpectOptionsParam3 sets up expected param options for PVZOrderRepository.GetOrders
func (mmGetOrders *mPVZOrderRepositoryMockGetOrders) ExpectOptionsParam3(options ...abstractions.GetOrdersOptFunc) *mPVZOrderRepositoryMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &PVZOrderRepositoryMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.options = &options
	mmGetOrders.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmGetOrders
}

// Inspect accepts an inspector function that has same arguments as the PVZOrderRepository.GetOrders
func (mmGetOrders *mPVZOrderRepositoryMockGetOrders) Inspect(f func(ctx context.Context, userID string, options ...abstractions.GetOrdersOptFunc)) *mPVZOrderRepositoryMockGetOrders {
	if mmGetOrders.mock.inspectFuncGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("Inspect function is already set for PVZOrderRepositoryMock.GetOrders")
	}

	mmGetOrders.mock.inspectFuncGetOrders = f

	return mmGetOrders
}

// Return sets up results that will be returned by PVZOrderRepository.GetOrders
func (mmGetOrders *mPVZOrderRepositoryMockGetOrders) Return(pa1 []domain.PVZOrder, err error) *PVZOrderRepositoryMock {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &PVZOrderRepositoryMockGetOrdersExpectation{mock: mmGetOrders.mock}
	}
	mmGetOrders.defaultExpectation.results = &PVZOrderRepositoryMockGetOrdersResults{pa1, err}
	mmGetOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrders.mock
}

// Set uses given function f to mock the PVZOrderRepository.GetOrders method
func (mmGetOrders *mPVZOrderRepositoryMockGetOrders) Set(f func(ctx context.Context, userID string, options ...abstractions.GetOrdersOptFunc) (pa1 []domain.PVZOrder, err error)) *PVZOrderRepositoryMock {
	if mmGetOrders.defaultExpectation != nil {
		mmGetOrders.mock.t.Fatalf("Default expectation is already set for the PVZOrderRepository.GetOrders method")
	}

	if len(mmGetOrders.expectations) > 0 {
		mmGetOrders.mock.t.Fatalf("Some expectations are already set for the PVZOrderRepository.GetOrders method")
	}

	mmGetOrders.mock.funcGetOrders = f
	mmGetOrders.mock.funcGetOrdersOrigin = minimock.CallerInfo(1)
	return mmGetOrders.mock
}

// When sets expectation for the PVZOrderRepository.GetOrders which will trigger the result defined by the following
// Then helper
func (mmGetOrders *mPVZOrderRepositoryMockGetOrders) When(ctx context.Context, userID string, options ...abstractions.GetOrdersOptFunc) *PVZOrderRepositoryMockGetOrdersExpectation {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderRepositoryMock.GetOrders mock is already set by Set")
	}

	expectation := &PVZOrderRepositoryMockGetOrdersExpectation{
		mock:               mmGetOrders.mock,
		params:             &PVZOrderRepositoryMockGetOrdersParams{ctx, userID, options},
		expectationOrigins: PVZOrderRepositoryMockGetOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrders.expectations = append(mmGetOrders.expectations, expectation)
	return expectation
}

// Then sets up PVZOrderRepository.GetOrders return parameters for the expectation previously defined by the When method
func (e *PVZOrderRepositoryMockGetOrdersExpectation) Then(pa1 []domain.PVZOrder, err error) *PVZOrderRepositoryMock {
	e.results = &PVZOrderRepositoryMockGetOrdersResults{pa1, err}
	return e.mock
}

// Times sets number of times PVZOrderRepository.GetOrders should be invoked
func (mmGetOrders *mPVZOrderRepositoryMockGetOrders) Times(n uint64) *mPVZOrderRepositoryMockGetOrders {
	if n == 0 {
		mmGetOrders.mock.t.Fatalf("Times of PVZOrderRepositoryMock.GetOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrders.expectedInvocations, n)
	mmGetOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrders
}

func (mmGetOrders *mPVZOrderRepositoryMockGetOrders) invocationsDone() bool {
	if len(mmGetOrders.expectations) == 0 && mmGetOrders.defaultExpectation == nil && mmGetOrders.mock.funcGetOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrders.mock.afterGetOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrders implements mm_usecases.PVZOrderRepository
func (mmGetOrders *PVZOrderRepositoryMock) GetOrders(ctx context.Context, userID string, options ...abstractions.GetOrdersOptFunc) (pa1 []domain.PVZOrder, err error) {
	mm_atomic.AddUint64(&mmGetOrders.beforeGetOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrders.afterGetOrdersCounter, 1)

	mmGetOrders.t.Helper()

	if mmGetOrders.inspectFuncGetOrders != nil {
		mmGetOrders.inspectFuncGetOrders(ctx, userID, options...)
	}

	mm_params := PVZOrderRepositoryMockGetOrdersParams{ctx, userID, options}

	// Record call args
	mmGetOrders.GetOrdersMock.mutex.Lock()
	mmGetOrders.GetOrdersMock.callArgs = append(mmGetOrders.GetOrdersMock.callArgs, &mm_params)
	mmGetOrders.GetOrdersMock.mutex.Unlock()

	for _, e := range mmGetOrders.GetOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetOrders.GetOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrders.GetOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrders.GetOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrders.GetOrdersMock.defaultExpectation.paramPtrs

		mm_got := PVZOrderRepositoryMockGetOrdersParams{ctx, userID, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrders.t.Errorf("PVZOrderRepositoryMock.GetOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetOrders.t.Errorf("PVZOrderRepositoryMock.GetOrders got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmGetOrders.t.Errorf("PVZOrderRepositoryMock.GetOrders got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrders.t.Errorf("PVZOrderRepositoryMock.GetOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrders.GetOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrders.t.Fatal("No results are set for the PVZOrderRepositoryMock.GetOrders")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetOrders.funcGetOrders != nil {
		return mmGetOrders.funcGetOrders(ctx, userID, options...)
	}
	mmGetOrders.t.Fatalf("Unexpected call to PVZOrderRepositoryMock.GetOrders. %v %v %v", ctx, userID, options)
	return
}

// GetOrdersAfterCounter returns a count of finished PVZOrderRepositoryMock.GetOrders invocations
func (mmGetOrders *PVZOrderRepositoryMock) GetOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrders.afterGetOrdersCounter)
}

// GetOrdersBeforeCounter returns a count of PVZOrderRepositoryMock.GetOrders invocations
func (mmGetOrders *PVZOrderRepositoryMock) GetOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrders.beforeGetOrdersCounter)
}

// Calls returns a list of arguments used in each call to PVZOrderRepositoryMock.GetOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrders *mPVZOrderRepositoryMockGetOrders) Calls() []*PVZOrderRepositoryMockGetOrdersParams {
	mmGetOrders.mutex.RLock()

	argCopy := make([]*PVZOrderRepositoryMockGetOrdersParams, len(mmGetOrders.callArgs))
	copy(argCopy, mmGetOrders.callArgs)

	mmGetOrders.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrdersDone returns true if the count of the GetOrders invocations corresponds
// the number of defined expectations
func (m *PVZOrderRepositoryMock) MinimockGetOrdersDone() bool {
	if m.GetOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrdersMock.invocationsDone()
}

// MinimockGetOrdersInspect logs each unmet expectation
func (m *PVZOrderRepositoryMock) MinimockGetOrdersInspect() {
	for _, e := range m.GetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.GetOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrdersCounter := mm_atomic.LoadUint64(&m.afterGetOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrdersMock.defaultExpectation != nil && afterGetOrdersCounter < 1 {
		if m.GetOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.GetOrders at\n%s", m.GetOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.GetOrders at\n%s with params: %#v", m.GetOrdersMock.defaultExpectation.expectationOrigins.origin, *m.GetOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrders != nil && afterGetOrdersCounter < 1 {
		m.t.Errorf("Expected call to PVZOrderRepositoryMock.GetOrders at\n%s", m.funcGetOrdersOrigin)
	}

	if !m.GetOrdersMock.invocationsDone() && afterGetOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZOrderRepositoryMock.GetOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrdersMock.expectedInvocations), m.GetOrdersMock.expectedInvocationsOrigin, afterGetOrdersCounter)
	}
}

type mPVZOrderRepositoryMockGetReturns struct {
	optional           bool
	mock               *PVZOrderRepositoryMock
	defaultExpectation *PVZOrderRepositoryMockGetReturnsExpectation
	expectations       []*PVZOrderRepositoryMockGetReturnsExpectation

	callArgs []*PVZOrderRepositoryMockGetReturnsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZOrderRepositoryMockGetReturnsExpectation specifies expectation struct of the PVZOrderRepository.GetReturns
type PVZOrderRepositoryMockGetReturnsExpectation struct {
	mock               *PVZOrderRepositoryMock
	params             *PVZOrderRepositoryMockGetReturnsParams
	paramPtrs          *PVZOrderRepositoryMockGetReturnsParamPtrs
	expectationOrigins PVZOrderRepositoryMockGetReturnsExpectationOrigins
	results            *PVZOrderRepositoryMockGetReturnsResults
	returnOrigin       string
	Counter            uint64
}

// PVZOrderRepositoryMockGetReturnsParams contains parameters of the PVZOrderRepository.GetReturns
type PVZOrderRepositoryMockGetReturnsParams struct {
	ctx     context.Context
	options []abstractions.PagePaginationOptFunc
}

// PVZOrderRepositoryMockGetReturnsParamPtrs contains pointers to parameters of the PVZOrderRepository.GetReturns
type PVZOrderRepositoryMockGetReturnsParamPtrs struct {
	ctx     *context.Context
	options *[]abstractions.PagePaginationOptFunc
}

// PVZOrderRepositoryMockGetReturnsResults contains results of the PVZOrderRepository.GetReturns
type PVZOrderRepositoryMockGetReturnsResults struct {
	pa1 []domain.PVZOrder
	err error
}

// PVZOrderRepositoryMockGetReturnsOrigins contains origins of expectations of the PVZOrderRepository.GetReturns
type PVZOrderRepositoryMockGetReturnsExpectationOrigins struct {
	origin        string
	originCtx     string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReturns *mPVZOrderRepositoryMockGetReturns) Optional() *mPVZOrderRepositoryMockGetReturns {
	mmGetReturns.optional = true
	return mmGetReturns
}

// Expect sets up expected params for PVZOrderRepository.GetReturns
func (mmGetReturns *mPVZOrderRepositoryMockGetReturns) Expect(ctx context.Context, options ...abstractions.PagePaginationOptFunc) *mPVZOrderRepositoryMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderRepositoryMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &PVZOrderRepositoryMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.paramPtrs != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderRepositoryMock.GetReturns mock is already set by ExpectParams functions")
	}

	mmGetReturns.defaultExpectation.params = &PVZOrderRepositoryMockGetReturnsParams{ctx, options}
	mmGetReturns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReturns.expectations {
		if minimock.Equal(e.params, mmGetReturns.defaultExpectation.params) {
			mmGetReturns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReturns.defaultExpectation.params)
		}
	}

	return mmGetReturns
}

// ExpectCtxParam1 sets up expected param ctx for PVZOrderRepository.GetReturns
func (mmGetReturns *mPVZOrderRepositoryMockGetReturns) ExpectCtxParam1(ctx context.Context) *mPVZOrderRepositoryMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderRepositoryMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &PVZOrderRepositoryMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.params != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderRepositoryMock.GetReturns mock is already set by Expect")
	}

	if mmGetReturns.defaultExpectation.paramPtrs == nil {
		mmGetReturns.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockGetReturnsParamPtrs{}
	}
	mmGetReturns.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetReturns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetReturns
}

// ExpectOptionsParam2 sets up expected param options for PVZOrderRepository.GetReturns
func (mmGetReturns *mPVZOrderRepositoryMockGetReturns) ExpectOptionsParam2(options ...abstractions.PagePaginationOptFunc) *mPVZOrderRepositoryMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderRepositoryMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &PVZOrderRepositoryMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.params != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderRepositoryMock.GetReturns mock is already set by Expect")
	}

	if mmGetReturns.defaultExpectation.paramPtrs == nil {
		mmGetReturns.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockGetReturnsParamPtrs{}
	}
	mmGetReturns.defaultExpectation.paramPtrs.options = &options
	mmGetReturns.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmGetReturns
}

// Inspect accepts an inspector function that has same arguments as the PVZOrderRepository.GetReturns
func (mmGetReturns *mPVZOrderRepositoryMockGetReturns) Inspect(f func(ctx context.Context, options ...abstractions.PagePaginationOptFunc)) *mPVZOrderRepositoryMockGetReturns {
	if mmGetReturns.mock.inspectFuncGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("Inspect function is already set for PVZOrderRepositoryMock.GetReturns")
	}

	mmGetReturns.mock.inspectFuncGetReturns = f

	return mmGetReturns
}

// Return sets up results that will be returned by PVZOrderRepository.GetReturns
func (mmGetReturns *mPVZOrderRepositoryMockGetReturns) Return(pa1 []domain.PVZOrder, err error) *PVZOrderRepositoryMock {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderRepositoryMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &PVZOrderRepositoryMockGetReturnsExpectation{mock: mmGetReturns.mock}
	}
	mmGetReturns.defaultExpectation.results = &PVZOrderRepositoryMockGetReturnsResults{pa1, err}
	mmGetReturns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReturns.mock
}

// Set uses given function f to mock the PVZOrderRepository.GetReturns method
func (mmGetReturns *mPVZOrderRepositoryMockGetReturns) Set(f func(ctx context.Context, options ...abstractions.PagePaginationOptFunc) (pa1 []domain.PVZOrder, err error)) *PVZOrderRepositoryMock {
	if mmGetReturns.defaultExpectation != nil {
		mmGetReturns.mock.t.Fatalf("Default expectation is already set for the PVZOrderRepository.GetReturns method")
	}

	if len(mmGetReturns.expectations) > 0 {
		mmGetReturns.mock.t.Fatalf("Some expectations are already set for the PVZOrderRepository.GetReturns method")
	}

	mmGetReturns.mock.funcGetReturns = f
	mmGetReturns.mock.funcGetReturnsOrigin = minimock.CallerInfo(1)
	return mmGetReturns.mock
}

// When sets expectation for the PVZOrderRepository.GetReturns which will trigger the result defined by the following
// Then helper
func (mmGetReturns *mPVZOrderRepositoryMockGetReturns) When(ctx context.Context, options ...abstractions.PagePaginationOptFunc) *PVZOrderRepositoryMockGetReturnsExpectation {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderRepositoryMock.GetReturns mock is already set by Set")
	}

	expectation := &PVZOrderRepositoryMockGetReturnsExpectation{
		mock:               mmGetReturns.mock,
		params:             &PVZOrderRepositoryMockGetReturnsParams{ctx, options},
		expectationOrigins: PVZOrderRepositoryMockGetReturnsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReturns.expectations = append(mmGetReturns.expectations, expectation)
	return expectation
}

// Then sets up PVZOrderRepository.GetReturns return parameters for the expectation previously defined by the When method
func (e *PVZOrderRepositoryMockGetReturnsExpectation) Then(pa1 []domain.PVZOrder, err error) *PVZOrderRepositoryMock {
	e.results = &PVZOrderRepositoryMockGetReturnsResults{pa1, err}
	return e.mock
}

// Times sets number of times PVZOrderRepository.GetReturns should be invoked
func (mmGetReturns *mPVZOrderRepositoryMockGetReturns) Times(n uint64) *mPVZOrderRepositoryMockGetReturns {
	if n == 0 {
		mmGetReturns.mock.t.Fatalf("Times of PVZOrderRepositoryMock.GetReturns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReturns.expectedInvocations, n)
	mmGetReturns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReturns
}

func (mmGetReturns *mPVZOrderRepositoryMockGetReturns) invocationsDone() bool {
	if len(mmGetReturns.expectations) == 0 && mmGetReturns.defaultExpectation == nil && mmGetReturns.mock.funcGetReturns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReturns.mock.afterGetReturnsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReturns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReturns implements mm_usecases.PVZOrderRepository
func (mmGetReturns *PVZOrderRepositoryMock) GetReturns(ctx context.Context, options ...abstractions.PagePaginationOptFunc) (pa1 []domain.PVZOrder, err error) {
	mm_atomic.AddUint64(&mmGetReturns.beforeGetReturnsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReturns.afterGetReturnsCounter, 1)

	mmGetReturns.t.Helper()

	if mmGetReturns.inspectFuncGetReturns != nil {
		mmGetReturns.inspectFuncGetReturns(ctx, options...)
	}

	mm_params := PVZOrderRepositoryMockGetReturnsParams{ctx, options}

	// Record call args
	mmGetReturns.GetReturnsMock.mutex.Lock()
	mmGetReturns.GetReturnsMock.callArgs = append(mmGetReturns.GetReturnsMock.callArgs, &mm_params)
	mmGetReturns.GetReturnsMock.mutex.Unlock()

	for _, e := range mmGetReturns.GetReturnsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetReturns.GetReturnsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReturns.GetReturnsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReturns.GetReturnsMock.defaultExpectation.params
		mm_want_ptrs := mmGetReturns.GetReturnsMock.defaultExpectation.paramPtrs

		mm_got := PVZOrderRepositoryMockGetReturnsParams{ctx, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetReturns.t.Errorf("PVZOrderRepositoryMock.GetReturns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmGetReturns.t.Errorf("PVZOrderRepositoryMock.GetReturns got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReturns.t.Errorf("PVZOrderRepositoryMock.GetReturns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReturns.GetReturnsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReturns.t.Fatal("No results are set for the PVZOrderRepositoryMock.GetReturns")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetReturns.funcGetReturns != nil {
		return mmGetReturns.funcGetReturns(ctx, options...)
	}
	mmGetReturns.t.Fatalf("Unexpected call to PVZOrderRepositoryMock.GetReturns. %v %v", ctx, options)
	return
}

// GetReturnsAfterCounter returns a count of finished PVZOrderRepositoryMock.GetReturns invocations
func (mmGetReturns *PVZOrderRepositoryMock) GetReturnsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturns.afterGetReturnsCounter)
}

// GetReturnsBeforeCounter returns a count of PVZOrderRepositoryMock.GetReturns invocations
func (mmGetReturns *PVZOrderRepositoryMock) GetReturnsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturns.beforeGetReturnsCounter)
}

// Calls returns a list of arguments used in each call to PVZOrderRepositoryMock.GetReturns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReturns *mPVZOrderRepositoryMockGetReturns) Calls() []*PVZOrderRepositoryMockGetReturnsParams {
	mmGetReturns.mutex.RLock()

	argCopy := make([]*PVZOrderRepositoryMockGetReturnsParams, len(mmGetReturns.callArgs))
	copy(argCopy, mmGetReturns.callArgs)

	mmGetReturns.mutex.RUnlock()

	return argCopy
}

// MinimockGetReturnsDone returns true if the count of the GetReturns invocations corresponds
// the number of defined expectations
func (m *PVZOrderRepositoryMock) MinimockGetReturnsDone() bool {
	if m.GetReturnsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReturnsMock.invocationsDone()
}

// MinimockGetReturnsInspect logs each unmet expectation
func (m *PVZOrderRepositoryMock) MinimockGetReturnsInspect() {
	for _, e := range m.GetReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.GetReturns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReturnsCounter := mm_atomic.LoadUint64(&m.afterGetReturnsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReturnsMock.defaultExpectation != nil && afterGetReturnsCounter < 1 {
		if m.GetReturnsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.GetReturns at\n%s", m.GetReturnsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.GetReturns at\n%s with params: %#v", m.GetReturnsMock.defaultExpectation.expectationOrigins.origin, *m.GetReturnsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReturns != nil && afterGetReturnsCounter < 1 {
		m.t.Errorf("Expected call to PVZOrderRepositoryMock.GetReturns at\n%s", m.funcGetReturnsOrigin)
	}

	if !m.GetReturnsMock.invocationsDone() && afterGetReturnsCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZOrderRepositoryMock.GetReturns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReturnsMock.expectedInvocations), m.GetReturnsMock.expectedInvocationsOrigin, afterGetReturnsCounter)
	}
}

type mPVZOrderRepositoryMockSetOrderIssued struct {
	optional           bool
	mock               *PVZOrderRepositoryMock
	defaultExpectation *PVZOrderRepositoryMockSetOrderIssuedExpectation
	expectations       []*PVZOrderRepositoryMockSetOrderIssuedExpectation

	callArgs []*PVZOrderRepositoryMockSetOrderIssuedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZOrderRepositoryMockSetOrderIssuedExpectation specifies expectation struct of the PVZOrderRepository.SetOrderIssued
type PVZOrderRepositoryMockSetOrderIssuedExpectation struct {
	mock               *PVZOrderRepositoryMock
	params             *PVZOrderRepositoryMockSetOrderIssuedParams
	paramPtrs          *PVZOrderRepositoryMockSetOrderIssuedParamPtrs
	expectationOrigins PVZOrderRepositoryMockSetOrderIssuedExpectationOrigins
	results            *PVZOrderRepositoryMockSetOrderIssuedResults
	returnOrigin       string
	Counter            uint64
}

// PVZOrderRepositoryMockSetOrderIssuedParams contains parameters of the PVZOrderRepository.SetOrderIssued
type PVZOrderRepositoryMockSetOrderIssuedParams struct {
	ctx     context.Context
	orderID string
}

// PVZOrderRepositoryMockSetOrderIssuedParamPtrs contains pointers to parameters of the PVZOrderRepository.SetOrderIssued
type PVZOrderRepositoryMockSetOrderIssuedParamPtrs struct {
	ctx     *context.Context
	orderID *string
}

// PVZOrderRepositoryMockSetOrderIssuedResults contains results of the PVZOrderRepository.SetOrderIssued
type PVZOrderRepositoryMockSetOrderIssuedResults struct {
	err error
}

// PVZOrderRepositoryMockSetOrderIssuedOrigins contains origins of expectations of the PVZOrderRepository.SetOrderIssued
type PVZOrderRepositoryMockSetOrderIssuedExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetOrderIssued *mPVZOrderRepositoryMockSetOrderIssued) Optional() *mPVZOrderRepositoryMockSetOrderIssued {
	mmSetOrderIssued.optional = true
	return mmSetOrderIssued
}

// Expect sets up expected params for PVZOrderRepository.SetOrderIssued
func (mmSetOrderIssued *mPVZOrderRepositoryMockSetOrderIssued) Expect(ctx context.Context, orderID string) *mPVZOrderRepositoryMockSetOrderIssued {
	if mmSetOrderIssued.mock.funcSetOrderIssued != nil {
		mmSetOrderIssued.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderIssued mock is already set by Set")
	}

	if mmSetOrderIssued.defaultExpectation == nil {
		mmSetOrderIssued.defaultExpectation = &PVZOrderRepositoryMockSetOrderIssuedExpectation{}
	}

	if mmSetOrderIssued.defaultExpectation.paramPtrs != nil {
		mmSetOrderIssued.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderIssued mock is already set by ExpectParams functions")
	}

	mmSetOrderIssued.defaultExpectation.params = &PVZOrderRepositoryMockSetOrderIssuedParams{ctx, orderID}
	mmSetOrderIssued.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetOrderIssued.expectations {
		if minimock.Equal(e.params, mmSetOrderIssued.defaultExpectation.params) {
			mmSetOrderIssued.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetOrderIssued.defaultExpectation.params)
		}
	}

	return mmSetOrderIssued
}

// ExpectCtxParam1 sets up expected param ctx for PVZOrderRepository.SetOrderIssued
func (mmSetOrderIssued *mPVZOrderRepositoryMockSetOrderIssued) ExpectCtxParam1(ctx context.Context) *mPVZOrderRepositoryMockSetOrderIssued {
	if mmSetOrderIssued.mock.funcSetOrderIssued != nil {
		mmSetOrderIssued.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderIssued mock is already set by Set")
	}

	if mmSetOrderIssued.defaultExpectation == nil {
		mmSetOrderIssued.defaultExpectation = &PVZOrderRepositoryMockSetOrderIssuedExpectation{}
	}

	if mmSetOrderIssued.defaultExpectation.params != nil {
		mmSetOrderIssued.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderIssued mock is already set by Expect")
	}

	if mmSetOrderIssued.defaultExpectation.paramPtrs == nil {
		mmSetOrderIssued.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockSetOrderIssuedParamPtrs{}
	}
	mmSetOrderIssued.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetOrderIssued.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetOrderIssued
}

// ExpectOrderIDParam2 sets up expected param orderID for PVZOrderRepository.SetOrderIssued
func (mmSetOrderIssued *mPVZOrderRepositoryMockSetOrderIssued) ExpectOrderIDParam2(orderID string) *mPVZOrderRepositoryMockSetOrderIssued {
	if mmSetOrderIssued.mock.funcSetOrderIssued != nil {
		mmSetOrderIssued.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderIssued mock is already set by Set")
	}

	if mmSetOrderIssued.defaultExpectation == nil {
		mmSetOrderIssued.defaultExpectation = &PVZOrderRepositoryMockSetOrderIssuedExpectation{}
	}

	if mmSetOrderIssued.defaultExpectation.params != nil {
		mmSetOrderIssued.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderIssued mock is already set by Expect")
	}

	if mmSetOrderIssued.defaultExpectation.paramPtrs == nil {
		mmSetOrderIssued.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockSetOrderIssuedParamPtrs{}
	}
	mmSetOrderIssued.defaultExpectation.paramPtrs.orderID = &orderID
	mmSetOrderIssued.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmSetOrderIssued
}

// Inspect accepts an inspector function that has same arguments as the PVZOrderRepository.SetOrderIssued
func (mmSetOrderIssued *mPVZOrderRepositoryMockSetOrderIssued) Inspect(f func(ctx context.Context, orderID string)) *mPVZOrderRepositoryMockSetOrderIssued {
	if mmSetOrderIssued.mock.inspectFuncSetOrderIssued != nil {
		mmSetOrderIssued.mock.t.Fatalf("Inspect function is already set for PVZOrderRepositoryMock.SetOrderIssued")
	}

	mmSetOrderIssued.mock.inspectFuncSetOrderIssued = f

	return mmSetOrderIssued
}

// Return sets up results that will be returned by PVZOrderRepository.SetOrderIssued
func (mmSetOrderIssued *mPVZOrderRepositoryMockSetOrderIssued) Return(err error) *PVZOrderRepositoryMock {
	if mmSetOrderIssued.mock.funcSetOrderIssued != nil {
		mmSetOrderIssued.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderIssued mock is already set by Set")
	}

	if mmSetOrderIssued.defaultExpectation == nil {
		mmSetOrderIssued.defaultExpectation = &PVZOrderRepositoryMockSetOrderIssuedExpectation{mock: mmSetOrderIssued.mock}
	}
	mmSetOrderIssued.defaultExpectation.results = &PVZOrderRepositoryMockSetOrderIssuedResults{err}
	mmSetOrderIssued.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetOrderIssued.mock
}

// Set uses given function f to mock the PVZOrderRepository.SetOrderIssued method
func (mmSetOrderIssued *mPVZOrderRepositoryMockSetOrderIssued) Set(f func(ctx context.Context, orderID string) (err error)) *PVZOrderRepositoryMock {
	if mmSetOrderIssued.defaultExpectation != nil {
		mmSetOrderIssued.mock.t.Fatalf("Default expectation is already set for the PVZOrderRepository.SetOrderIssued method")
	}

	if len(mmSetOrderIssued.expectations) > 0 {
		mmSetOrderIssued.mock.t.Fatalf("Some expectations are already set for the PVZOrderRepository.SetOrderIssued method")
	}

	mmSetOrderIssued.mock.funcSetOrderIssued = f
	mmSetOrderIssued.mock.funcSetOrderIssuedOrigin = minimock.CallerInfo(1)
	return mmSetOrderIssued.mock
}

// When sets expectation for the PVZOrderRepository.SetOrderIssued which will trigger the result defined by the following
// Then helper
func (mmSetOrderIssued *mPVZOrderRepositoryMockSetOrderIssued) When(ctx context.Context, orderID string) *PVZOrderRepositoryMockSetOrderIssuedExpectation {
	if mmSetOrderIssued.mock.funcSetOrderIssued != nil {
		mmSetOrderIssued.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderIssued mock is already set by Set")
	}

	expectation := &PVZOrderRepositoryMockSetOrderIssuedExpectation{
		mock:               mmSetOrderIssued.mock,
		params:             &PVZOrderRepositoryMockSetOrderIssuedParams{ctx, orderID},
		expectationOrigins: PVZOrderRepositoryMockSetOrderIssuedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetOrderIssued.expectations = append(mmSetOrderIssued.expectations, expectation)
	return expectation
}

// Then sets up PVZOrderRepository.SetOrderIssued return parameters for the expectation previously defined by the When method
func (e *PVZOrderRepositoryMockSetOrderIssuedExpectation) Then(err error) *PVZOrderRepositoryMock {
	e.results = &PVZOrderRepositoryMockSetOrderIssuedResults{err}
	return e.mock
}

// Times sets number of times PVZOrderRepository.SetOrderIssued should be invoked
func (mmSetOrderIssued *mPVZOrderRepositoryMockSetOrderIssued) Times(n uint64) *mPVZOrderRepositoryMockSetOrderIssued {
	if n == 0 {
		mmSetOrderIssued.mock.t.Fatalf("Times of PVZOrderRepositoryMock.SetOrderIssued mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetOrderIssued.expectedInvocations, n)
	mmSetOrderIssued.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetOrderIssued
}

func (mmSetOrderIssued *mPVZOrderRepositoryMockSetOrderIssued) invocationsDone() bool {
	if len(mmSetOrderIssued.expectations) == 0 && mmSetOrderIssued.defaultExpectation == nil && mmSetOrderIssued.mock.funcSetOrderIssued == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetOrderIssued.mock.afterSetOrderIssuedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetOrderIssued.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetOrderIssued implements mm_usecases.PVZOrderRepository
func (mmSetOrderIssued *PVZOrderRepositoryMock) SetOrderIssued(ctx context.Context, orderID string) (err error) {
	mm_atomic.AddUint64(&mmSetOrderIssued.beforeSetOrderIssuedCounter, 1)
	defer mm_atomic.AddUint64(&mmSetOrderIssued.afterSetOrderIssuedCounter, 1)

	mmSetOrderIssued.t.Helper()

	if mmSetOrderIssued.inspectFuncSetOrderIssued != nil {
		mmSetOrderIssued.inspectFuncSetOrderIssued(ctx, orderID)
	}

	mm_params := PVZOrderRepositoryMockSetOrderIssuedParams{ctx, orderID}

	// Record call args
	mmSetOrderIssued.SetOrderIssuedMock.mutex.Lock()
	mmSetOrderIssued.SetOrderIssuedMock.callArgs = append(mmSetOrderIssued.SetOrderIssuedMock.callArgs, &mm_params)
	mmSetOrderIssued.SetOrderIssuedMock.mutex.Unlock()

	for _, e := range mmSetOrderIssued.SetOrderIssuedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetOrderIssued.SetOrderIssuedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetOrderIssued.SetOrderIssuedMock.defaultExpectation.Counter, 1)
		mm_want := mmSetOrderIssued.SetOrderIssuedMock.defaultExpectation.params
		mm_want_ptrs := mmSetOrderIssued.SetOrderIssuedMock.defaultExpectation.paramPtrs

		mm_got := PVZOrderRepositoryMockSetOrderIssuedParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetOrderIssued.t.Errorf("PVZOrderRepositoryMock.SetOrderIssued got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOrderIssued.SetOrderIssuedMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmSetOrderIssued.t.Errorf("PVZOrderRepositoryMock.SetOrderIssued got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOrderIssued.SetOrderIssuedMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetOrderIssued.t.Errorf("PVZOrderRepositoryMock.SetOrderIssued got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetOrderIssued.SetOrderIssuedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetOrderIssued.SetOrderIssuedMock.defaultExpectation.results
		if mm_results == nil {
			mmSetOrderIssued.t.Fatal("No results are set for the PVZOrderRepositoryMock.SetOrderIssued")
		}
		return (*mm_results).err
	}
	if mmSetOrderIssued.funcSetOrderIssued != nil {
		return mmSetOrderIssued.funcSetOrderIssued(ctx, orderID)
	}
	mmSetOrderIssued.t.Fatalf("Unexpected call to PVZOrderRepositoryMock.SetOrderIssued. %v %v", ctx, orderID)
	return
}

// SetOrderIssuedAfterCounter returns a count of finished PVZOrderRepositoryMock.SetOrderIssued invocations
func (mmSetOrderIssued *PVZOrderRepositoryMock) SetOrderIssuedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOrderIssued.afterSetOrderIssuedCounter)
}

// SetOrderIssuedBeforeCounter returns a count of PVZOrderRepositoryMock.SetOrderIssued invocations
func (mmSetOrderIssued *PVZOrderRepositoryMock) SetOrderIssuedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOrderIssued.beforeSetOrderIssuedCounter)
}

// Calls returns a list of arguments used in each call to PVZOrderRepositoryMock.SetOrderIssued.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetOrderIssued *mPVZOrderRepositoryMockSetOrderIssued) Calls() []*PVZOrderRepositoryMockSetOrderIssuedParams {
	mmSetOrderIssued.mutex.RLock()

	argCopy := make([]*PVZOrderRepositoryMockSetOrderIssuedParams, len(mmSetOrderIssued.callArgs))
	copy(argCopy, mmSetOrderIssued.callArgs)

	mmSetOrderIssued.mutex.RUnlock()

	return argCopy
}

// MinimockSetOrderIssuedDone returns true if the count of the SetOrderIssued invocations corresponds
// the number of defined expectations
func (m *PVZOrderRepositoryMock) MinimockSetOrderIssuedDone() bool {
	if m.SetOrderIssuedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetOrderIssuedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetOrderIssuedMock.invocationsDone()
}

// MinimockSetOrderIssuedInspect logs each unmet expectation
func (m *PVZOrderRepositoryMock) MinimockSetOrderIssuedInspect() {
	for _, e := range m.SetOrderIssuedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.SetOrderIssued at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetOrderIssuedCounter := mm_atomic.LoadUint64(&m.afterSetOrderIssuedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetOrderIssuedMock.defaultExpectation != nil && afterSetOrderIssuedCounter < 1 {
		if m.SetOrderIssuedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.SetOrderIssued at\n%s", m.SetOrderIssuedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.SetOrderIssued at\n%s with params: %#v", m.SetOrderIssuedMock.defaultExpectation.expectationOrigins.origin, *m.SetOrderIssuedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetOrderIssued != nil && afterSetOrderIssuedCounter < 1 {
		m.t.Errorf("Expected call to PVZOrderRepositoryMock.SetOrderIssued at\n%s", m.funcSetOrderIssuedOrigin)
	}

	if !m.SetOrderIssuedMock.invocationsDone() && afterSetOrderIssuedCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZOrderRepositoryMock.SetOrderIssued at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetOrderIssuedMock.expectedInvocations), m.SetOrderIssuedMock.expectedInvocationsOrigin, afterSetOrderIssuedCounter)
	}
}

type mPVZOrderRepositoryMockSetOrderReturned struct {
	optional           bool
	mock               *PVZOrderRepositoryMock
	defaultExpectation *PVZOrderRepositoryMockSetOrderReturnedExpectation
	expectations       []*PVZOrderRepositoryMockSetOrderReturnedExpectation

	callArgs []*PVZOrderRepositoryMockSetOrderReturnedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZOrderRepositoryMockSetOrderReturnedExpectation specifies expectation struct of the PVZOrderRepository.SetOrderReturned
type PVZOrderRepositoryMockSetOrderReturnedExpectation struct {
	mock               *PVZOrderRepositoryMock
	params             *PVZOrderRepositoryMockSetOrderReturnedParams
	paramPtrs          *PVZOrderRepositoryMockSetOrderReturnedParamPtrs
	expectationOrigins PVZOrderRepositoryMockSetOrderReturnedExpectationOrigins
	results            *PVZOrderRepositoryMockSetOrderReturnedResults
	returnOrigin       string
	Counter            uint64
}

// PVZOrderRepositoryMockSetOrderReturnedParams contains parameters of the PVZOrderRepository.SetOrderReturned
type PVZOrderRepositoryMockSetOrderReturnedParams struct {
	ctx     context.Context
	orderID string
}

// PVZOrderRepositoryMockSetOrderReturnedParamPtrs contains pointers to parameters of the PVZOrderRepository.SetOrderReturned
type PVZOrderRepositoryMockSetOrderReturnedParamPtrs struct {
	ctx     *context.Context
	orderID *string
}

// PVZOrderRepositoryMockSetOrderReturnedResults contains results of the PVZOrderRepository.SetOrderReturned
type PVZOrderRepositoryMockSetOrderReturnedResults struct {
	err error
}

// PVZOrderRepositoryMockSetOrderReturnedOrigins contains origins of expectations of the PVZOrderRepository.SetOrderReturned
type PVZOrderRepositoryMockSetOrderReturnedExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetOrderReturned *mPVZOrderRepositoryMockSetOrderReturned) Optional() *mPVZOrderRepositoryMockSetOrderReturned {
	mmSetOrderReturned.optional = true
	return mmSetOrderReturned
}

// Expect sets up expected params for PVZOrderRepository.SetOrderReturned
func (mmSetOrderReturned *mPVZOrderRepositoryMockSetOrderReturned) Expect(ctx context.Context, orderID string) *mPVZOrderRepositoryMockSetOrderReturned {
	if mmSetOrderReturned.mock.funcSetOrderReturned != nil {
		mmSetOrderReturned.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderReturned mock is already set by Set")
	}

	if mmSetOrderReturned.defaultExpectation == nil {
		mmSetOrderReturned.defaultExpectation = &PVZOrderRepositoryMockSetOrderReturnedExpectation{}
	}

	if mmSetOrderReturned.defaultExpectation.paramPtrs != nil {
		mmSetOrderReturned.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderReturned mock is already set by ExpectParams functions")
	}

	mmSetOrderReturned.defaultExpectation.params = &PVZOrderRepositoryMockSetOrderReturnedParams{ctx, orderID}
	mmSetOrderReturned.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetOrderReturned.expectations {
		if minimock.Equal(e.params, mmSetOrderReturned.defaultExpectation.params) {
			mmSetOrderReturned.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetOrderReturned.defaultExpectation.params)
		}
	}

	return mmSetOrderReturned
}

// ExpectCtxParam1 sets up expected param ctx for PVZOrderRepository.SetOrderReturned
func (mmSetOrderReturned *mPVZOrderRepositoryMockSetOrderReturned) ExpectCtxParam1(ctx context.Context) *mPVZOrderRepositoryMockSetOrderReturned {
	if mmSetOrderReturned.mock.funcSetOrderReturned != nil {
		mmSetOrderReturned.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderReturned mock is already set by Set")
	}

	if mmSetOrderReturned.defaultExpectation == nil {
		mmSetOrderReturned.defaultExpectation = &PVZOrderRepositoryMockSetOrderReturnedExpectation{}
	}

	if mmSetOrderReturned.defaultExpectation.params != nil {
		mmSetOrderReturned.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderReturned mock is already set by Expect")
	}

	if mmSetOrderReturned.defaultExpectation.paramPtrs == nil {
		mmSetOrderReturned.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockSetOrderReturnedParamPtrs{}
	}
	mmSetOrderReturned.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetOrderReturned.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetOrderReturned
}

// ExpectOrderIDParam2 sets up expected param orderID for PVZOrderRepository.SetOrderReturned
func (mmSetOrderReturned *mPVZOrderRepositoryMockSetOrderReturned) ExpectOrderIDParam2(orderID string) *mPVZOrderRepositoryMockSetOrderReturned {
	if mmSetOrderReturned.mock.funcSetOrderReturned != nil {
		mmSetOrderReturned.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderReturned mock is already set by Set")
	}

	if mmSetOrderReturned.defaultExpectation == nil {
		mmSetOrderReturned.defaultExpectation = &PVZOrderRepositoryMockSetOrderReturnedExpectation{}
	}

	if mmSetOrderReturned.defaultExpectation.params != nil {
		mmSetOrderReturned.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderReturned mock is already set by Expect")
	}

	if mmSetOrderReturned.defaultExpectation.paramPtrs == nil {
		mmSetOrderReturned.defaultExpectation.paramPtrs = &PVZOrderRepositoryMockSetOrderReturnedParamPtrs{}
	}
	mmSetOrderReturned.defaultExpectation.paramPtrs.orderID = &orderID
	mmSetOrderReturned.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmSetOrderReturned
}

// Inspect accepts an inspector function that has same arguments as the PVZOrderRepository.SetOrderReturned
func (mmSetOrderReturned *mPVZOrderRepositoryMockSetOrderReturned) Inspect(f func(ctx context.Context, orderID string)) *mPVZOrderRepositoryMockSetOrderReturned {
	if mmSetOrderReturned.mock.inspectFuncSetOrderReturned != nil {
		mmSetOrderReturned.mock.t.Fatalf("Inspect function is already set for PVZOrderRepositoryMock.SetOrderReturned")
	}

	mmSetOrderReturned.mock.inspectFuncSetOrderReturned = f

	return mmSetOrderReturned
}

// Return sets up results that will be returned by PVZOrderRepository.SetOrderReturned
func (mmSetOrderReturned *mPVZOrderRepositoryMockSetOrderReturned) Return(err error) *PVZOrderRepositoryMock {
	if mmSetOrderReturned.mock.funcSetOrderReturned != nil {
		mmSetOrderReturned.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderReturned mock is already set by Set")
	}

	if mmSetOrderReturned.defaultExpectation == nil {
		mmSetOrderReturned.defaultExpectation = &PVZOrderRepositoryMockSetOrderReturnedExpectation{mock: mmSetOrderReturned.mock}
	}
	mmSetOrderReturned.defaultExpectation.results = &PVZOrderRepositoryMockSetOrderReturnedResults{err}
	mmSetOrderReturned.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetOrderReturned.mock
}

// Set uses given function f to mock the PVZOrderRepository.SetOrderReturned method
func (mmSetOrderReturned *mPVZOrderRepositoryMockSetOrderReturned) Set(f func(ctx context.Context, orderID string) (err error)) *PVZOrderRepositoryMock {
	if mmSetOrderReturned.defaultExpectation != nil {
		mmSetOrderReturned.mock.t.Fatalf("Default expectation is already set for the PVZOrderRepository.SetOrderReturned method")
	}

	if len(mmSetOrderReturned.expectations) > 0 {
		mmSetOrderReturned.mock.t.Fatalf("Some expectations are already set for the PVZOrderRepository.SetOrderReturned method")
	}

	mmSetOrderReturned.mock.funcSetOrderReturned = f
	mmSetOrderReturned.mock.funcSetOrderReturnedOrigin = minimock.CallerInfo(1)
	return mmSetOrderReturned.mock
}

// When sets expectation for the PVZOrderRepository.SetOrderReturned which will trigger the result defined by the following
// Then helper
func (mmSetOrderReturned *mPVZOrderRepositoryMockSetOrderReturned) When(ctx context.Context, orderID string) *PVZOrderRepositoryMockSetOrderReturnedExpectation {
	if mmSetOrderReturned.mock.funcSetOrderReturned != nil {
		mmSetOrderReturned.mock.t.Fatalf("PVZOrderRepositoryMock.SetOrderReturned mock is already set by Set")
	}

	expectation := &PVZOrderRepositoryMockSetOrderReturnedExpectation{
		mock:               mmSetOrderReturned.mock,
		params:             &PVZOrderRepositoryMockSetOrderReturnedParams{ctx, orderID},
		expectationOrigins: PVZOrderRepositoryMockSetOrderReturnedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetOrderReturned.expectations = append(mmSetOrderReturned.expectations, expectation)
	return expectation
}

// Then sets up PVZOrderRepository.SetOrderReturned return parameters for the expectation previously defined by the When method
func (e *PVZOrderRepositoryMockSetOrderReturnedExpectation) Then(err error) *PVZOrderRepositoryMock {
	e.results = &PVZOrderRepositoryMockSetOrderReturnedResults{err}
	return e.mock
}

// Times sets number of times PVZOrderRepository.SetOrderReturned should be invoked
func (mmSetOrderReturned *mPVZOrderRepositoryMockSetOrderReturned) Times(n uint64) *mPVZOrderRepositoryMockSetOrderReturned {
	if n == 0 {
		mmSetOrderReturned.mock.t.Fatalf("Times of PVZOrderRepositoryMock.SetOrderReturned mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetOrderReturned.expectedInvocations, n)
	mmSetOrderReturned.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetOrderReturned
}

func (mmSetOrderReturned *mPVZOrderRepositoryMockSetOrderReturned) invocationsDone() bool {
	if len(mmSetOrderReturned.expectations) == 0 && mmSetOrderReturned.defaultExpectation == nil && mmSetOrderReturned.mock.funcSetOrderReturned == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetOrderReturned.mock.afterSetOrderReturnedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetOrderReturned.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetOrderReturned implements mm_usecases.PVZOrderRepository
func (mmSetOrderReturned *PVZOrderRepositoryMock) SetOrderReturned(ctx context.Context, orderID string) (err error) {
	mm_atomic.AddUint64(&mmSetOrderReturned.beforeSetOrderReturnedCounter, 1)
	defer mm_atomic.AddUint64(&mmSetOrderReturned.afterSetOrderReturnedCounter, 1)

	mmSetOrderReturned.t.Helper()

	if mmSetOrderReturned.inspectFuncSetOrderReturned != nil {
		mmSetOrderReturned.inspectFuncSetOrderReturned(ctx, orderID)
	}

	mm_params := PVZOrderRepositoryMockSetOrderReturnedParams{ctx, orderID}

	// Record call args
	mmSetOrderReturned.SetOrderReturnedMock.mutex.Lock()
	mmSetOrderReturned.SetOrderReturnedMock.callArgs = append(mmSetOrderReturned.SetOrderReturnedMock.callArgs, &mm_params)
	mmSetOrderReturned.SetOrderReturnedMock.mutex.Unlock()

	for _, e := range mmSetOrderReturned.SetOrderReturnedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetOrderReturned.SetOrderReturnedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetOrderReturned.SetOrderReturnedMock.defaultExpectation.Counter, 1)
		mm_want := mmSetOrderReturned.SetOrderReturnedMock.defaultExpectation.params
		mm_want_ptrs := mmSetOrderReturned.SetOrderReturnedMock.defaultExpectation.paramPtrs

		mm_got := PVZOrderRepositoryMockSetOrderReturnedParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetOrderReturned.t.Errorf("PVZOrderRepositoryMock.SetOrderReturned got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOrderReturned.SetOrderReturnedMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmSetOrderReturned.t.Errorf("PVZOrderRepositoryMock.SetOrderReturned got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOrderReturned.SetOrderReturnedMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetOrderReturned.t.Errorf("PVZOrderRepositoryMock.SetOrderReturned got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetOrderReturned.SetOrderReturnedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetOrderReturned.SetOrderReturnedMock.defaultExpectation.results
		if mm_results == nil {
			mmSetOrderReturned.t.Fatal("No results are set for the PVZOrderRepositoryMock.SetOrderReturned")
		}
		return (*mm_results).err
	}
	if mmSetOrderReturned.funcSetOrderReturned != nil {
		return mmSetOrderReturned.funcSetOrderReturned(ctx, orderID)
	}
	mmSetOrderReturned.t.Fatalf("Unexpected call to PVZOrderRepositoryMock.SetOrderReturned. %v %v", ctx, orderID)
	return
}

// SetOrderReturnedAfterCounter returns a count of finished PVZOrderRepositoryMock.SetOrderReturned invocations
func (mmSetOrderReturned *PVZOrderRepositoryMock) SetOrderReturnedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOrderReturned.afterSetOrderReturnedCounter)
}

// SetOrderReturnedBeforeCounter returns a count of PVZOrderRepositoryMock.SetOrderReturned invocations
func (mmSetOrderReturned *PVZOrderRepositoryMock) SetOrderReturnedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOrderReturned.beforeSetOrderReturnedCounter)
}

// Calls returns a list of arguments used in each call to PVZOrderRepositoryMock.SetOrderReturned.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetOrderReturned *mPVZOrderRepositoryMockSetOrderReturned) Calls() []*PVZOrderRepositoryMockSetOrderReturnedParams {
	mmSetOrderReturned.mutex.RLock()

	argCopy := make([]*PVZOrderRepositoryMockSetOrderReturnedParams, len(mmSetOrderReturned.callArgs))
	copy(argCopy, mmSetOrderReturned.callArgs)

	mmSetOrderReturned.mutex.RUnlock()

	return argCopy
}

// MinimockSetOrderReturnedDone returns true if the count of the SetOrderReturned invocations corresponds
// the number of defined expectations
func (m *PVZOrderRepositoryMock) MinimockSetOrderReturnedDone() bool {
	if m.SetOrderReturnedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetOrderReturnedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetOrderReturnedMock.invocationsDone()
}

// MinimockSetOrderReturnedInspect logs each unmet expectation
func (m *PVZOrderRepositoryMock) MinimockSetOrderReturnedInspect() {
	for _, e := range m.SetOrderReturnedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.SetOrderReturned at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetOrderReturnedCounter := mm_atomic.LoadUint64(&m.afterSetOrderReturnedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetOrderReturnedMock.defaultExpectation != nil && afterSetOrderReturnedCounter < 1 {
		if m.SetOrderReturnedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.SetOrderReturned at\n%s", m.SetOrderReturnedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZOrderRepositoryMock.SetOrderReturned at\n%s with params: %#v", m.SetOrderReturnedMock.defaultExpectation.expectationOrigins.origin, *m.SetOrderReturnedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetOrderReturned != nil && afterSetOrderReturnedCounter < 1 {
		m.t.Errorf("Expected call to PVZOrderRepositoryMock.SetOrderReturned at\n%s", m.funcSetOrderReturnedOrigin)
	}

	if !m.SetOrderReturnedMock.invocationsDone() && afterSetOrderReturnedCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZOrderRepositoryMock.SetOrderReturned at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetOrderReturnedMock.expectedInvocations), m.SetOrderReturnedMock.expectedInvocationsOrigin, afterSetOrderReturnedCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PVZOrderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateOrderInspect()

			m.MinimockDeleteOrderInspect()

			m.MinimockGetOrderInspect()

			m.MinimockGetOrdersInspect()

			m.MinimockGetReturnsInspect()

			m.MinimockSetOrderIssuedInspect()

			m.MinimockSetOrderReturnedInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PVZOrderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PVZOrderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateOrderDone() &&
		m.MinimockDeleteOrderDone() &&
		m.MinimockGetOrderDone() &&
		m.MinimockGetOrdersDone() &&
		m.MinimockGetReturnsDone() &&
		m.MinimockSetOrderIssuedDone() &&
		m.MinimockSetOrderReturnedDone()
}
