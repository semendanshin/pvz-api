// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

import (
	"context"
	"homework/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	_ "github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// EventsRepositoryMock implements mm_usecases.EventsRepository
type EventsRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetPendingEvents          func(ctx context.Context, limit int) (ea1 []domain.Event, err error)
	funcGetPendingEventsOrigin    string
	inspectFuncGetPendingEvents   func(ctx context.Context, limit int)
	afterGetPendingEventsCounter  uint64
	beforeGetPendingEventsCounter uint64
	GetPendingEventsMock          mEventsRepositoryMockGetPendingEvents

	funcMarkAsSent          func(ctx context.Context, id uuid.UUID) (err error)
	funcMarkAsSentOrigin    string
	inspectFuncMarkAsSent   func(ctx context.Context, id uuid.UUID)
	afterMarkAsSentCounter  uint64
	beforeMarkAsSentCounter uint64
	MarkAsSentMock          mEventsRepositoryMockMarkAsSent
}

// NewEventsRepositoryMock returns a mock for mm_usecases.EventsRepository
func NewEventsRepositoryMock(t minimock.Tester) *EventsRepositoryMock {
	m := &EventsRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetPendingEventsMock = mEventsRepositoryMockGetPendingEvents{mock: m}
	m.GetPendingEventsMock.callArgs = []*EventsRepositoryMockGetPendingEventsParams{}

	m.MarkAsSentMock = mEventsRepositoryMockMarkAsSent{mock: m}
	m.MarkAsSentMock.callArgs = []*EventsRepositoryMockMarkAsSentParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mEventsRepositoryMockGetPendingEvents struct {
	optional           bool
	mock               *EventsRepositoryMock
	defaultExpectation *EventsRepositoryMockGetPendingEventsExpectation
	expectations       []*EventsRepositoryMockGetPendingEventsExpectation

	callArgs []*EventsRepositoryMockGetPendingEventsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EventsRepositoryMockGetPendingEventsExpectation specifies expectation struct of the EventsRepository.GetPendingEvents
type EventsRepositoryMockGetPendingEventsExpectation struct {
	mock               *EventsRepositoryMock
	params             *EventsRepositoryMockGetPendingEventsParams
	paramPtrs          *EventsRepositoryMockGetPendingEventsParamPtrs
	expectationOrigins EventsRepositoryMockGetPendingEventsExpectationOrigins
	results            *EventsRepositoryMockGetPendingEventsResults
	returnOrigin       string
	Counter            uint64
}

// EventsRepositoryMockGetPendingEventsParams contains parameters of the EventsRepository.GetPendingEvents
type EventsRepositoryMockGetPendingEventsParams struct {
	ctx   context.Context
	limit int
}

// EventsRepositoryMockGetPendingEventsParamPtrs contains pointers to parameters of the EventsRepository.GetPendingEvents
type EventsRepositoryMockGetPendingEventsParamPtrs struct {
	ctx   *context.Context
	limit *int
}

// EventsRepositoryMockGetPendingEventsResults contains results of the EventsRepository.GetPendingEvents
type EventsRepositoryMockGetPendingEventsResults struct {
	ea1 []domain.Event
	err error
}

// EventsRepositoryMockGetPendingEventsOrigins contains origins of expectations of the EventsRepository.GetPendingEvents
type EventsRepositoryMockGetPendingEventsExpectationOrigins struct {
	origin      string
	originCtx   string
	originLimit string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPendingEvents *mEventsRepositoryMockGetPendingEvents) Optional() *mEventsRepositoryMockGetPendingEvents {
	mmGetPendingEvents.optional = true
	return mmGetPendingEvents
}

// Expect sets up expected params for EventsRepository.GetPendingEvents
func (mmGetPendingEvents *mEventsRepositoryMockGetPendingEvents) Expect(ctx context.Context, limit int) *mEventsRepositoryMockGetPendingEvents {
	if mmGetPendingEvents.mock.funcGetPendingEvents != nil {
		mmGetPendingEvents.mock.t.Fatalf("EventsRepositoryMock.GetPendingEvents mock is already set by Set")
	}

	if mmGetPendingEvents.defaultExpectation == nil {
		mmGetPendingEvents.defaultExpectation = &EventsRepositoryMockGetPendingEventsExpectation{}
	}

	if mmGetPendingEvents.defaultExpectation.paramPtrs != nil {
		mmGetPendingEvents.mock.t.Fatalf("EventsRepositoryMock.GetPendingEvents mock is already set by ExpectParams functions")
	}

	mmGetPendingEvents.defaultExpectation.params = &EventsRepositoryMockGetPendingEventsParams{ctx, limit}
	mmGetPendingEvents.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPendingEvents.expectations {
		if minimock.Equal(e.params, mmGetPendingEvents.defaultExpectation.params) {
			mmGetPendingEvents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPendingEvents.defaultExpectation.params)
		}
	}

	return mmGetPendingEvents
}

// ExpectCtxParam1 sets up expected param ctx for EventsRepository.GetPendingEvents
func (mmGetPendingEvents *mEventsRepositoryMockGetPendingEvents) ExpectCtxParam1(ctx context.Context) *mEventsRepositoryMockGetPendingEvents {
	if mmGetPendingEvents.mock.funcGetPendingEvents != nil {
		mmGetPendingEvents.mock.t.Fatalf("EventsRepositoryMock.GetPendingEvents mock is already set by Set")
	}

	if mmGetPendingEvents.defaultExpectation == nil {
		mmGetPendingEvents.defaultExpectation = &EventsRepositoryMockGetPendingEventsExpectation{}
	}

	if mmGetPendingEvents.defaultExpectation.params != nil {
		mmGetPendingEvents.mock.t.Fatalf("EventsRepositoryMock.GetPendingEvents mock is already set by Expect")
	}

	if mmGetPendingEvents.defaultExpectation.paramPtrs == nil {
		mmGetPendingEvents.defaultExpectation.paramPtrs = &EventsRepositoryMockGetPendingEventsParamPtrs{}
	}
	mmGetPendingEvents.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPendingEvents.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPendingEvents
}

// ExpectLimitParam2 sets up expected param limit for EventsRepository.GetPendingEvents
func (mmGetPendingEvents *mEventsRepositoryMockGetPendingEvents) ExpectLimitParam2(limit int) *mEventsRepositoryMockGetPendingEvents {
	if mmGetPendingEvents.mock.funcGetPendingEvents != nil {
		mmGetPendingEvents.mock.t.Fatalf("EventsRepositoryMock.GetPendingEvents mock is already set by Set")
	}

	if mmGetPendingEvents.defaultExpectation == nil {
		mmGetPendingEvents.defaultExpectation = &EventsRepositoryMockGetPendingEventsExpectation{}
	}

	if mmGetPendingEvents.defaultExpectation.params != nil {
		mmGetPendingEvents.mock.t.Fatalf("EventsRepositoryMock.GetPendingEvents mock is already set by Expect")
	}

	if mmGetPendingEvents.defaultExpectation.paramPtrs == nil {
		mmGetPendingEvents.defaultExpectation.paramPtrs = &EventsRepositoryMockGetPendingEventsParamPtrs{}
	}
	mmGetPendingEvents.defaultExpectation.paramPtrs.limit = &limit
	mmGetPendingEvents.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetPendingEvents
}

// Inspect accepts an inspector function that has same arguments as the EventsRepository.GetPendingEvents
func (mmGetPendingEvents *mEventsRepositoryMockGetPendingEvents) Inspect(f func(ctx context.Context, limit int)) *mEventsRepositoryMockGetPendingEvents {
	if mmGetPendingEvents.mock.inspectFuncGetPendingEvents != nil {
		mmGetPendingEvents.mock.t.Fatalf("Inspect function is already set for EventsRepositoryMock.GetPendingEvents")
	}

	mmGetPendingEvents.mock.inspectFuncGetPendingEvents = f

	return mmGetPendingEvents
}

// Return sets up results that will be returned by EventsRepository.GetPendingEvents
func (mmGetPendingEvents *mEventsRepositoryMockGetPendingEvents) Return(ea1 []domain.Event, err error) *EventsRepositoryMock {
	if mmGetPendingEvents.mock.funcGetPendingEvents != nil {
		mmGetPendingEvents.mock.t.Fatalf("EventsRepositoryMock.GetPendingEvents mock is already set by Set")
	}

	if mmGetPendingEvents.defaultExpectation == nil {
		mmGetPendingEvents.defaultExpectation = &EventsRepositoryMockGetPendingEventsExpectation{mock: mmGetPendingEvents.mock}
	}
	mmGetPendingEvents.defaultExpectation.results = &EventsRepositoryMockGetPendingEventsResults{ea1, err}
	mmGetPendingEvents.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPendingEvents.mock
}

// Set uses given function f to mock the EventsRepository.GetPendingEvents method
func (mmGetPendingEvents *mEventsRepositoryMockGetPendingEvents) Set(f func(ctx context.Context, limit int) (ea1 []domain.Event, err error)) *EventsRepositoryMock {
	if mmGetPendingEvents.defaultExpectation != nil {
		mmGetPendingEvents.mock.t.Fatalf("Default expectation is already set for the EventsRepository.GetPendingEvents method")
	}

	if len(mmGetPendingEvents.expectations) > 0 {
		mmGetPendingEvents.mock.t.Fatalf("Some expectations are already set for the EventsRepository.GetPendingEvents method")
	}

	mmGetPendingEvents.mock.funcGetPendingEvents = f
	mmGetPendingEvents.mock.funcGetPendingEventsOrigin = minimock.CallerInfo(1)
	return mmGetPendingEvents.mock
}

// When sets expectation for the EventsRepository.GetPendingEvents which will trigger the result defined by the following
// Then helper
func (mmGetPendingEvents *mEventsRepositoryMockGetPendingEvents) When(ctx context.Context, limit int) *EventsRepositoryMockGetPendingEventsExpectation {
	if mmGetPendingEvents.mock.funcGetPendingEvents != nil {
		mmGetPendingEvents.mock.t.Fatalf("EventsRepositoryMock.GetPendingEvents mock is already set by Set")
	}

	expectation := &EventsRepositoryMockGetPendingEventsExpectation{
		mock:               mmGetPendingEvents.mock,
		params:             &EventsRepositoryMockGetPendingEventsParams{ctx, limit},
		expectationOrigins: EventsRepositoryMockGetPendingEventsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPendingEvents.expectations = append(mmGetPendingEvents.expectations, expectation)
	return expectation
}

// Then sets up EventsRepository.GetPendingEvents return parameters for the expectation previously defined by the When method
func (e *EventsRepositoryMockGetPendingEventsExpectation) Then(ea1 []domain.Event, err error) *EventsRepositoryMock {
	e.results = &EventsRepositoryMockGetPendingEventsResults{ea1, err}
	return e.mock
}

// Times sets number of times EventsRepository.GetPendingEvents should be invoked
func (mmGetPendingEvents *mEventsRepositoryMockGetPendingEvents) Times(n uint64) *mEventsRepositoryMockGetPendingEvents {
	if n == 0 {
		mmGetPendingEvents.mock.t.Fatalf("Times of EventsRepositoryMock.GetPendingEvents mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPendingEvents.expectedInvocations, n)
	mmGetPendingEvents.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPendingEvents
}

func (mmGetPendingEvents *mEventsRepositoryMockGetPendingEvents) invocationsDone() bool {
	if len(mmGetPendingEvents.expectations) == 0 && mmGetPendingEvents.defaultExpectation == nil && mmGetPendingEvents.mock.funcGetPendingEvents == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPendingEvents.mock.afterGetPendingEventsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPendingEvents.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPendingEvents implements mm_usecases.EventsRepository
func (mmGetPendingEvents *EventsRepositoryMock) GetPendingEvents(ctx context.Context, limit int) (ea1 []domain.Event, err error) {
	mm_atomic.AddUint64(&mmGetPendingEvents.beforeGetPendingEventsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPendingEvents.afterGetPendingEventsCounter, 1)

	mmGetPendingEvents.t.Helper()

	if mmGetPendingEvents.inspectFuncGetPendingEvents != nil {
		mmGetPendingEvents.inspectFuncGetPendingEvents(ctx, limit)
	}

	mm_params := EventsRepositoryMockGetPendingEventsParams{ctx, limit}

	// Record call args
	mmGetPendingEvents.GetPendingEventsMock.mutex.Lock()
	mmGetPendingEvents.GetPendingEventsMock.callArgs = append(mmGetPendingEvents.GetPendingEventsMock.callArgs, &mm_params)
	mmGetPendingEvents.GetPendingEventsMock.mutex.Unlock()

	for _, e := range mmGetPendingEvents.GetPendingEventsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetPendingEvents.GetPendingEventsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPendingEvents.GetPendingEventsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPendingEvents.GetPendingEventsMock.defaultExpectation.params
		mm_want_ptrs := mmGetPendingEvents.GetPendingEventsMock.defaultExpectation.paramPtrs

		mm_got := EventsRepositoryMockGetPendingEventsParams{ctx, limit}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPendingEvents.t.Errorf("EventsRepositoryMock.GetPendingEvents got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPendingEvents.GetPendingEventsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetPendingEvents.t.Errorf("EventsRepositoryMock.GetPendingEvents got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPendingEvents.GetPendingEventsMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPendingEvents.t.Errorf("EventsRepositoryMock.GetPendingEvents got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPendingEvents.GetPendingEventsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPendingEvents.GetPendingEventsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPendingEvents.t.Fatal("No results are set for the EventsRepositoryMock.GetPendingEvents")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetPendingEvents.funcGetPendingEvents != nil {
		return mmGetPendingEvents.funcGetPendingEvents(ctx, limit)
	}
	mmGetPendingEvents.t.Fatalf("Unexpected call to EventsRepositoryMock.GetPendingEvents. %v %v", ctx, limit)
	return
}

// GetPendingEventsAfterCounter returns a count of finished EventsRepositoryMock.GetPendingEvents invocations
func (mmGetPendingEvents *EventsRepositoryMock) GetPendingEventsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPendingEvents.afterGetPendingEventsCounter)
}

// GetPendingEventsBeforeCounter returns a count of EventsRepositoryMock.GetPendingEvents invocations
func (mmGetPendingEvents *EventsRepositoryMock) GetPendingEventsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPendingEvents.beforeGetPendingEventsCounter)
}

// Calls returns a list of arguments used in each call to EventsRepositoryMock.GetPendingEvents.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPendingEvents *mEventsRepositoryMockGetPendingEvents) Calls() []*EventsRepositoryMockGetPendingEventsParams {
	mmGetPendingEvents.mutex.RLock()

	argCopy := make([]*EventsRepositoryMockGetPendingEventsParams, len(mmGetPendingEvents.callArgs))
	copy(argCopy, mmGetPendingEvents.callArgs)

	mmGetPendingEvents.mutex.RUnlock()

	return argCopy
}

// MinimockGetPendingEventsDone returns true if the count of the GetPendingEvents invocations corresponds
// the number of defined expectations
func (m *EventsRepositoryMock) MinimockGetPendingEventsDone() bool {
	if m.GetPendingEventsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPendingEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPendingEventsMock.invocationsDone()
}

// MinimockGetPendingEventsInspect logs each unmet expectation
func (m *EventsRepositoryMock) MinimockGetPendingEventsInspect() {
	for _, e := range m.GetPendingEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventsRepositoryMock.GetPendingEvents at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPendingEventsCounter := mm_atomic.LoadUint64(&m.afterGetPendingEventsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPendingEventsMock.defaultExpectation != nil && afterGetPendingEventsCounter < 1 {
		if m.GetPendingEventsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EventsRepositoryMock.GetPendingEvents at\n%s", m.GetPendingEventsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EventsRepositoryMock.GetPendingEvents at\n%s with params: %#v", m.GetPendingEventsMock.defaultExpectation.expectationOrigins.origin, *m.GetPendingEventsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPendingEvents != nil && afterGetPendingEventsCounter < 1 {
		m.t.Errorf("Expected call to EventsRepositoryMock.GetPendingEvents at\n%s", m.funcGetPendingEventsOrigin)
	}

	if !m.GetPendingEventsMock.invocationsDone() && afterGetPendingEventsCounter > 0 {
		m.t.Errorf("Expected %d calls to EventsRepositoryMock.GetPendingEvents at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPendingEventsMock.expectedInvocations), m.GetPendingEventsMock.expectedInvocationsOrigin, afterGetPendingEventsCounter)
	}
}

type mEventsRepositoryMockMarkAsSent struct {
	optional           bool
	mock               *EventsRepositoryMock
	defaultExpectation *EventsRepositoryMockMarkAsSentExpectation
	expectations       []*EventsRepositoryMockMarkAsSentExpectation

	callArgs []*EventsRepositoryMockMarkAsSentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// EventsRepositoryMockMarkAsSentExpectation specifies expectation struct of the EventsRepository.MarkAsSent
type EventsRepositoryMockMarkAsSentExpectation struct {
	mock               *EventsRepositoryMock
	params             *EventsRepositoryMockMarkAsSentParams
	paramPtrs          *EventsRepositoryMockMarkAsSentParamPtrs
	expectationOrigins EventsRepositoryMockMarkAsSentExpectationOrigins
	results            *EventsRepositoryMockMarkAsSentResults
	returnOrigin       string
	Counter            uint64
}

// EventsRepositoryMockMarkAsSentParams contains parameters of the EventsRepository.MarkAsSent
type EventsRepositoryMockMarkAsSentParams struct {
	ctx context.Context
	id  uuid.UUID
}

// EventsRepositoryMockMarkAsSentParamPtrs contains pointers to parameters of the EventsRepository.MarkAsSent
type EventsRepositoryMockMarkAsSentParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// EventsRepositoryMockMarkAsSentResults contains results of the EventsRepository.MarkAsSent
type EventsRepositoryMockMarkAsSentResults struct {
	err error
}

// EventsRepositoryMockMarkAsSentOrigins contains origins of expectations of the EventsRepository.MarkAsSent
type EventsRepositoryMockMarkAsSentExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMarkAsSent *mEventsRepositoryMockMarkAsSent) Optional() *mEventsRepositoryMockMarkAsSent {
	mmMarkAsSent.optional = true
	return mmMarkAsSent
}

// Expect sets up expected params for EventsRepository.MarkAsSent
func (mmMarkAsSent *mEventsRepositoryMockMarkAsSent) Expect(ctx context.Context, id uuid.UUID) *mEventsRepositoryMockMarkAsSent {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("EventsRepositoryMock.MarkAsSent mock is already set by Set")
	}

	if mmMarkAsSent.defaultExpectation == nil {
		mmMarkAsSent.defaultExpectation = &EventsRepositoryMockMarkAsSentExpectation{}
	}

	if mmMarkAsSent.defaultExpectation.paramPtrs != nil {
		mmMarkAsSent.mock.t.Fatalf("EventsRepositoryMock.MarkAsSent mock is already set by ExpectParams functions")
	}

	mmMarkAsSent.defaultExpectation.params = &EventsRepositoryMockMarkAsSentParams{ctx, id}
	mmMarkAsSent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMarkAsSent.expectations {
		if minimock.Equal(e.params, mmMarkAsSent.defaultExpectation.params) {
			mmMarkAsSent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMarkAsSent.defaultExpectation.params)
		}
	}

	return mmMarkAsSent
}

// ExpectCtxParam1 sets up expected param ctx for EventsRepository.MarkAsSent
func (mmMarkAsSent *mEventsRepositoryMockMarkAsSent) ExpectCtxParam1(ctx context.Context) *mEventsRepositoryMockMarkAsSent {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("EventsRepositoryMock.MarkAsSent mock is already set by Set")
	}

	if mmMarkAsSent.defaultExpectation == nil {
		mmMarkAsSent.defaultExpectation = &EventsRepositoryMockMarkAsSentExpectation{}
	}

	if mmMarkAsSent.defaultExpectation.params != nil {
		mmMarkAsSent.mock.t.Fatalf("EventsRepositoryMock.MarkAsSent mock is already set by Expect")
	}

	if mmMarkAsSent.defaultExpectation.paramPtrs == nil {
		mmMarkAsSent.defaultExpectation.paramPtrs = &EventsRepositoryMockMarkAsSentParamPtrs{}
	}
	mmMarkAsSent.defaultExpectation.paramPtrs.ctx = &ctx
	mmMarkAsSent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmMarkAsSent
}

// ExpectIdParam2 sets up expected param id for EventsRepository.MarkAsSent
func (mmMarkAsSent *mEventsRepositoryMockMarkAsSent) ExpectIdParam2(id uuid.UUID) *mEventsRepositoryMockMarkAsSent {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("EventsRepositoryMock.MarkAsSent mock is already set by Set")
	}

	if mmMarkAsSent.defaultExpectation == nil {
		mmMarkAsSent.defaultExpectation = &EventsRepositoryMockMarkAsSentExpectation{}
	}

	if mmMarkAsSent.defaultExpectation.params != nil {
		mmMarkAsSent.mock.t.Fatalf("EventsRepositoryMock.MarkAsSent mock is already set by Expect")
	}

	if mmMarkAsSent.defaultExpectation.paramPtrs == nil {
		mmMarkAsSent.defaultExpectation.paramPtrs = &EventsRepositoryMockMarkAsSentParamPtrs{}
	}
	mmMarkAsSent.defaultExpectation.paramPtrs.id = &id
	mmMarkAsSent.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmMarkAsSent
}

// Inspect accepts an inspector function that has same arguments as the EventsRepository.MarkAsSent
func (mmMarkAsSent *mEventsRepositoryMockMarkAsSent) Inspect(f func(ctx context.Context, id uuid.UUID)) *mEventsRepositoryMockMarkAsSent {
	if mmMarkAsSent.mock.inspectFuncMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("Inspect function is already set for EventsRepositoryMock.MarkAsSent")
	}

	mmMarkAsSent.mock.inspectFuncMarkAsSent = f

	return mmMarkAsSent
}

// Return sets up results that will be returned by EventsRepository.MarkAsSent
func (mmMarkAsSent *mEventsRepositoryMockMarkAsSent) Return(err error) *EventsRepositoryMock {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("EventsRepositoryMock.MarkAsSent mock is already set by Set")
	}

	if mmMarkAsSent.defaultExpectation == nil {
		mmMarkAsSent.defaultExpectation = &EventsRepositoryMockMarkAsSentExpectation{mock: mmMarkAsSent.mock}
	}
	mmMarkAsSent.defaultExpectation.results = &EventsRepositoryMockMarkAsSentResults{err}
	mmMarkAsSent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMarkAsSent.mock
}

// Set uses given function f to mock the EventsRepository.MarkAsSent method
func (mmMarkAsSent *mEventsRepositoryMockMarkAsSent) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *EventsRepositoryMock {
	if mmMarkAsSent.defaultExpectation != nil {
		mmMarkAsSent.mock.t.Fatalf("Default expectation is already set for the EventsRepository.MarkAsSent method")
	}

	if len(mmMarkAsSent.expectations) > 0 {
		mmMarkAsSent.mock.t.Fatalf("Some expectations are already set for the EventsRepository.MarkAsSent method")
	}

	mmMarkAsSent.mock.funcMarkAsSent = f
	mmMarkAsSent.mock.funcMarkAsSentOrigin = minimock.CallerInfo(1)
	return mmMarkAsSent.mock
}

// When sets expectation for the EventsRepository.MarkAsSent which will trigger the result defined by the following
// Then helper
func (mmMarkAsSent *mEventsRepositoryMockMarkAsSent) When(ctx context.Context, id uuid.UUID) *EventsRepositoryMockMarkAsSentExpectation {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("EventsRepositoryMock.MarkAsSent mock is already set by Set")
	}

	expectation := &EventsRepositoryMockMarkAsSentExpectation{
		mock:               mmMarkAsSent.mock,
		params:             &EventsRepositoryMockMarkAsSentParams{ctx, id},
		expectationOrigins: EventsRepositoryMockMarkAsSentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMarkAsSent.expectations = append(mmMarkAsSent.expectations, expectation)
	return expectation
}

// Then sets up EventsRepository.MarkAsSent return parameters for the expectation previously defined by the When method
func (e *EventsRepositoryMockMarkAsSentExpectation) Then(err error) *EventsRepositoryMock {
	e.results = &EventsRepositoryMockMarkAsSentResults{err}
	return e.mock
}

// Times sets number of times EventsRepository.MarkAsSent should be invoked
func (mmMarkAsSent *mEventsRepositoryMockMarkAsSent) Times(n uint64) *mEventsRepositoryMockMarkAsSent {
	if n == 0 {
		mmMarkAsSent.mock.t.Fatalf("Times of EventsRepositoryMock.MarkAsSent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMarkAsSent.expectedInvocations, n)
	mmMarkAsSent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMarkAsSent
}

func (mmMarkAsSent *mEventsRepositoryMockMarkAsSent) invocationsDone() bool {
	if len(mmMarkAsSent.expectations) == 0 && mmMarkAsSent.defaultExpectation == nil && mmMarkAsSent.mock.funcMarkAsSent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMarkAsSent.mock.afterMarkAsSentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMarkAsSent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MarkAsSent implements mm_usecases.EventsRepository
func (mmMarkAsSent *EventsRepositoryMock) MarkAsSent(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmMarkAsSent.beforeMarkAsSentCounter, 1)
	defer mm_atomic.AddUint64(&mmMarkAsSent.afterMarkAsSentCounter, 1)

	mmMarkAsSent.t.Helper()

	if mmMarkAsSent.inspectFuncMarkAsSent != nil {
		mmMarkAsSent.inspectFuncMarkAsSent(ctx, id)
	}

	mm_params := EventsRepositoryMockMarkAsSentParams{ctx, id}

	// Record call args
	mmMarkAsSent.MarkAsSentMock.mutex.Lock()
	mmMarkAsSent.MarkAsSentMock.callArgs = append(mmMarkAsSent.MarkAsSentMock.callArgs, &mm_params)
	mmMarkAsSent.MarkAsSentMock.mutex.Unlock()

	for _, e := range mmMarkAsSent.MarkAsSentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMarkAsSent.MarkAsSentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarkAsSent.MarkAsSentMock.defaultExpectation.Counter, 1)
		mm_want := mmMarkAsSent.MarkAsSentMock.defaultExpectation.params
		mm_want_ptrs := mmMarkAsSent.MarkAsSentMock.defaultExpectation.paramPtrs

		mm_got := EventsRepositoryMockMarkAsSentParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmMarkAsSent.t.Errorf("EventsRepositoryMock.MarkAsSent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkAsSent.MarkAsSentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmMarkAsSent.t.Errorf("EventsRepositoryMock.MarkAsSent got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkAsSent.MarkAsSentMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMarkAsSent.t.Errorf("EventsRepositoryMock.MarkAsSent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMarkAsSent.MarkAsSentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMarkAsSent.MarkAsSentMock.defaultExpectation.results
		if mm_results == nil {
			mmMarkAsSent.t.Fatal("No results are set for the EventsRepositoryMock.MarkAsSent")
		}
		return (*mm_results).err
	}
	if mmMarkAsSent.funcMarkAsSent != nil {
		return mmMarkAsSent.funcMarkAsSent(ctx, id)
	}
	mmMarkAsSent.t.Fatalf("Unexpected call to EventsRepositoryMock.MarkAsSent. %v %v", ctx, id)
	return
}

// MarkAsSentAfterCounter returns a count of finished EventsRepositoryMock.MarkAsSent invocations
func (mmMarkAsSent *EventsRepositoryMock) MarkAsSentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkAsSent.afterMarkAsSentCounter)
}

// MarkAsSentBeforeCounter returns a count of EventsRepositoryMock.MarkAsSent invocations
func (mmMarkAsSent *EventsRepositoryMock) MarkAsSentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkAsSent.beforeMarkAsSentCounter)
}

// Calls returns a list of arguments used in each call to EventsRepositoryMock.MarkAsSent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMarkAsSent *mEventsRepositoryMockMarkAsSent) Calls() []*EventsRepositoryMockMarkAsSentParams {
	mmMarkAsSent.mutex.RLock()

	argCopy := make([]*EventsRepositoryMockMarkAsSentParams, len(mmMarkAsSent.callArgs))
	copy(argCopy, mmMarkAsSent.callArgs)

	mmMarkAsSent.mutex.RUnlock()

	return argCopy
}

// MinimockMarkAsSentDone returns true if the count of the MarkAsSent invocations corresponds
// the number of defined expectations
func (m *EventsRepositoryMock) MinimockMarkAsSentDone() bool {
	if m.MarkAsSentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MarkAsSentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MarkAsSentMock.invocationsDone()
}

// MinimockMarkAsSentInspect logs each unmet expectation
func (m *EventsRepositoryMock) MinimockMarkAsSentInspect() {
	for _, e := range m.MarkAsSentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventsRepositoryMock.MarkAsSent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMarkAsSentCounter := mm_atomic.LoadUint64(&m.afterMarkAsSentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MarkAsSentMock.defaultExpectation != nil && afterMarkAsSentCounter < 1 {
		if m.MarkAsSentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to EventsRepositoryMock.MarkAsSent at\n%s", m.MarkAsSentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to EventsRepositoryMock.MarkAsSent at\n%s with params: %#v", m.MarkAsSentMock.defaultExpectation.expectationOrigins.origin, *m.MarkAsSentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkAsSent != nil && afterMarkAsSentCounter < 1 {
		m.t.Errorf("Expected call to EventsRepositoryMock.MarkAsSent at\n%s", m.funcMarkAsSentOrigin)
	}

	if !m.MarkAsSentMock.invocationsDone() && afterMarkAsSentCounter > 0 {
		m.t.Errorf("Expected %d calls to EventsRepositoryMock.MarkAsSent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MarkAsSentMock.expectedInvocations), m.MarkAsSentMock.expectedInvocationsOrigin, afterMarkAsSentCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *EventsRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetPendingEventsInspect()

			m.MinimockMarkAsSentInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *EventsRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *EventsRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetPendingEventsDone() &&
		m.MinimockMarkAsSentDone()
}
