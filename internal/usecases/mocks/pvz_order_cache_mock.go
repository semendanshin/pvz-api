// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

import (
	"context"
	"homework/internal/abstractions"
	"homework/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	_ "github.com/gojuno/minimock/v3"
)

// PVZOrderCacheMock implements mm_usecases.PVZOrderCache
type PVZOrderCacheMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetOrder          func(ctx context.Context, orderID string) (p1 domain.PVZOrder, e1 error, b1 bool)
	funcGetOrderOrigin    string
	inspectFuncGetOrder   func(ctx context.Context, orderID string)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mPVZOrderCacheMockGetOrder

	funcGetOrders          func(ctx context.Context, userID string, options ...abstractions.GetOrdersOptFunc) (pa1 []domain.PVZOrder, e1 error, b1 bool)
	funcGetOrdersOrigin    string
	inspectFuncGetOrders   func(ctx context.Context, userID string, options ...abstractions.GetOrdersOptFunc)
	afterGetOrdersCounter  uint64
	beforeGetOrdersCounter uint64
	GetOrdersMock          mPVZOrderCacheMockGetOrders

	funcGetReturns          func(ctx context.Context, options ...abstractions.PagePaginationOptFunc) (pa1 []domain.PVZOrder, e1 error, b1 bool)
	funcGetReturnsOrigin    string
	inspectFuncGetReturns   func(ctx context.Context, options ...abstractions.PagePaginationOptFunc)
	afterGetReturnsCounter  uint64
	beforeGetReturnsCounter uint64
	GetReturnsMock          mPVZOrderCacheMockGetReturns

	funcSetGetOrders          func(ctx context.Context, userID string, orders []domain.PVZOrder, options ...abstractions.GetOrdersOptFunc) (err error)
	funcSetGetOrdersOrigin    string
	inspectFuncSetGetOrders   func(ctx context.Context, userID string, orders []domain.PVZOrder, options ...abstractions.GetOrdersOptFunc)
	afterSetGetOrdersCounter  uint64
	beforeSetGetOrdersCounter uint64
	SetGetOrdersMock          mPVZOrderCacheMockSetGetOrders

	funcSetGetReturns          func(ctx context.Context, orders []domain.PVZOrder, options ...abstractions.PagePaginationOptFunc) (err error)
	funcSetGetReturnsOrigin    string
	inspectFuncSetGetReturns   func(ctx context.Context, orders []domain.PVZOrder, options ...abstractions.PagePaginationOptFunc)
	afterSetGetReturnsCounter  uint64
	beforeSetGetReturnsCounter uint64
	SetGetReturnsMock          mPVZOrderCacheMockSetGetReturns

	funcSetOrder          func(ctx context.Context, order domain.PVZOrder) (err error)
	funcSetOrderOrigin    string
	inspectFuncSetOrder   func(ctx context.Context, order domain.PVZOrder)
	afterSetOrderCounter  uint64
	beforeSetOrderCounter uint64
	SetOrderMock          mPVZOrderCacheMockSetOrder
}

// NewPVZOrderCacheMock returns a mock for mm_usecases.PVZOrderCache
func NewPVZOrderCacheMock(t minimock.Tester) *PVZOrderCacheMock {
	m := &PVZOrderCacheMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetOrderMock = mPVZOrderCacheMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*PVZOrderCacheMockGetOrderParams{}

	m.GetOrdersMock = mPVZOrderCacheMockGetOrders{mock: m}
	m.GetOrdersMock.callArgs = []*PVZOrderCacheMockGetOrdersParams{}

	m.GetReturnsMock = mPVZOrderCacheMockGetReturns{mock: m}
	m.GetReturnsMock.callArgs = []*PVZOrderCacheMockGetReturnsParams{}

	m.SetGetOrdersMock = mPVZOrderCacheMockSetGetOrders{mock: m}
	m.SetGetOrdersMock.callArgs = []*PVZOrderCacheMockSetGetOrdersParams{}

	m.SetGetReturnsMock = mPVZOrderCacheMockSetGetReturns{mock: m}
	m.SetGetReturnsMock.callArgs = []*PVZOrderCacheMockSetGetReturnsParams{}

	m.SetOrderMock = mPVZOrderCacheMockSetOrder{mock: m}
	m.SetOrderMock.callArgs = []*PVZOrderCacheMockSetOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPVZOrderCacheMockGetOrder struct {
	optional           bool
	mock               *PVZOrderCacheMock
	defaultExpectation *PVZOrderCacheMockGetOrderExpectation
	expectations       []*PVZOrderCacheMockGetOrderExpectation

	callArgs []*PVZOrderCacheMockGetOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZOrderCacheMockGetOrderExpectation specifies expectation struct of the PVZOrderCache.GetOrder
type PVZOrderCacheMockGetOrderExpectation struct {
	mock               *PVZOrderCacheMock
	params             *PVZOrderCacheMockGetOrderParams
	paramPtrs          *PVZOrderCacheMockGetOrderParamPtrs
	expectationOrigins PVZOrderCacheMockGetOrderExpectationOrigins
	results            *PVZOrderCacheMockGetOrderResults
	returnOrigin       string
	Counter            uint64
}

// PVZOrderCacheMockGetOrderParams contains parameters of the PVZOrderCache.GetOrder
type PVZOrderCacheMockGetOrderParams struct {
	ctx     context.Context
	orderID string
}

// PVZOrderCacheMockGetOrderParamPtrs contains pointers to parameters of the PVZOrderCache.GetOrder
type PVZOrderCacheMockGetOrderParamPtrs struct {
	ctx     *context.Context
	orderID *string
}

// PVZOrderCacheMockGetOrderResults contains results of the PVZOrderCache.GetOrder
type PVZOrderCacheMockGetOrderResults struct {
	p1 domain.PVZOrder
	e1 error
	b1 bool
}

// PVZOrderCacheMockGetOrderOrigins contains origins of expectations of the PVZOrderCache.GetOrder
type PVZOrderCacheMockGetOrderExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrder *mPVZOrderCacheMockGetOrder) Optional() *mPVZOrderCacheMockGetOrder {
	mmGetOrder.optional = true
	return mmGetOrder
}

// Expect sets up expected params for PVZOrderCache.GetOrder
func (mmGetOrder *mPVZOrderCacheMockGetOrder) Expect(ctx context.Context, orderID string) *mPVZOrderCacheMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderCacheMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &PVZOrderCacheMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.paramPtrs != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderCacheMock.GetOrder mock is already set by ExpectParams functions")
	}

	mmGetOrder.defaultExpectation.params = &PVZOrderCacheMockGetOrderParams{ctx, orderID}
	mmGetOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// ExpectCtxParam1 sets up expected param ctx for PVZOrderCache.GetOrder
func (mmGetOrder *mPVZOrderCacheMockGetOrder) ExpectCtxParam1(ctx context.Context) *mPVZOrderCacheMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderCacheMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &PVZOrderCacheMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderCacheMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &PVZOrderCacheMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for PVZOrderCache.GetOrder
func (mmGetOrder *mPVZOrderCacheMockGetOrder) ExpectOrderIDParam2(orderID string) *mPVZOrderCacheMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderCacheMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &PVZOrderCacheMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderCacheMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &PVZOrderCacheMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetOrder.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the PVZOrderCache.GetOrder
func (mmGetOrder *mPVZOrderCacheMockGetOrder) Inspect(f func(ctx context.Context, orderID string)) *mPVZOrderCacheMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for PVZOrderCacheMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by PVZOrderCache.GetOrder
func (mmGetOrder *mPVZOrderCacheMockGetOrder) Return(p1 domain.PVZOrder, e1 error, b1 bool) *PVZOrderCacheMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderCacheMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &PVZOrderCacheMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &PVZOrderCacheMockGetOrderResults{p1, e1, b1}
	mmGetOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// Set uses given function f to mock the PVZOrderCache.GetOrder method
func (mmGetOrder *mPVZOrderCacheMockGetOrder) Set(f func(ctx context.Context, orderID string) (p1 domain.PVZOrder, e1 error, b1 bool)) *PVZOrderCacheMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the PVZOrderCache.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the PVZOrderCache.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	mmGetOrder.mock.funcGetOrderOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// When sets expectation for the PVZOrderCache.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mPVZOrderCacheMockGetOrder) When(ctx context.Context, orderID string) *PVZOrderCacheMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("PVZOrderCacheMock.GetOrder mock is already set by Set")
	}

	expectation := &PVZOrderCacheMockGetOrderExpectation{
		mock:               mmGetOrder.mock,
		params:             &PVZOrderCacheMockGetOrderParams{ctx, orderID},
		expectationOrigins: PVZOrderCacheMockGetOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up PVZOrderCache.GetOrder return parameters for the expectation previously defined by the When method
func (e *PVZOrderCacheMockGetOrderExpectation) Then(p1 domain.PVZOrder, e1 error, b1 bool) *PVZOrderCacheMock {
	e.results = &PVZOrderCacheMockGetOrderResults{p1, e1, b1}
	return e.mock
}

// Times sets number of times PVZOrderCache.GetOrder should be invoked
func (mmGetOrder *mPVZOrderCacheMockGetOrder) Times(n uint64) *mPVZOrderCacheMockGetOrder {
	if n == 0 {
		mmGetOrder.mock.t.Fatalf("Times of PVZOrderCacheMock.GetOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrder.expectedInvocations, n)
	mmGetOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrder
}

func (mmGetOrder *mPVZOrderCacheMockGetOrder) invocationsDone() bool {
	if len(mmGetOrder.expectations) == 0 && mmGetOrder.defaultExpectation == nil && mmGetOrder.mock.funcGetOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrder.mock.afterGetOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrder implements mm_usecases.PVZOrderCache
func (mmGetOrder *PVZOrderCacheMock) GetOrder(ctx context.Context, orderID string) (p1 domain.PVZOrder, e1 error, b1 bool) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	mmGetOrder.t.Helper()

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(ctx, orderID)
	}

	mm_params := PVZOrderCacheMockGetOrderParams{ctx, orderID}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, &mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.e1, e.results.b1
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrder.GetOrderMock.defaultExpectation.paramPtrs

		mm_got := PVZOrderCacheMockGetOrderParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrder.t.Errorf("PVZOrderCacheMock.GetOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetOrder.t.Errorf("PVZOrderCacheMock.GetOrder got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("PVZOrderCacheMock.GetOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the PVZOrderCacheMock.GetOrder")
		}
		return (*mm_results).p1, (*mm_results).e1, (*mm_results).b1
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(ctx, orderID)
	}
	mmGetOrder.t.Fatalf("Unexpected call to PVZOrderCacheMock.GetOrder. %v %v", ctx, orderID)
	return
}

// GetOrderAfterCounter returns a count of finished PVZOrderCacheMock.GetOrder invocations
func (mmGetOrder *PVZOrderCacheMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of PVZOrderCacheMock.GetOrder invocations
func (mmGetOrder *PVZOrderCacheMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to PVZOrderCacheMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mPVZOrderCacheMockGetOrder) Calls() []*PVZOrderCacheMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*PVZOrderCacheMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *PVZOrderCacheMock) MinimockGetOrderDone() bool {
	if m.GetOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderMock.invocationsDone()
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *PVZOrderCacheMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZOrderCacheMock.GetOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderCounter := mm_atomic.LoadUint64(&m.afterGetOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && afterGetOrderCounter < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZOrderCacheMock.GetOrder at\n%s", m.GetOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZOrderCacheMock.GetOrder at\n%s with params: %#v", m.GetOrderMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && afterGetOrderCounter < 1 {
		m.t.Errorf("Expected call to PVZOrderCacheMock.GetOrder at\n%s", m.funcGetOrderOrigin)
	}

	if !m.GetOrderMock.invocationsDone() && afterGetOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZOrderCacheMock.GetOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderMock.expectedInvocations), m.GetOrderMock.expectedInvocationsOrigin, afterGetOrderCounter)
	}
}

type mPVZOrderCacheMockGetOrders struct {
	optional           bool
	mock               *PVZOrderCacheMock
	defaultExpectation *PVZOrderCacheMockGetOrdersExpectation
	expectations       []*PVZOrderCacheMockGetOrdersExpectation

	callArgs []*PVZOrderCacheMockGetOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZOrderCacheMockGetOrdersExpectation specifies expectation struct of the PVZOrderCache.GetOrders
type PVZOrderCacheMockGetOrdersExpectation struct {
	mock               *PVZOrderCacheMock
	params             *PVZOrderCacheMockGetOrdersParams
	paramPtrs          *PVZOrderCacheMockGetOrdersParamPtrs
	expectationOrigins PVZOrderCacheMockGetOrdersExpectationOrigins
	results            *PVZOrderCacheMockGetOrdersResults
	returnOrigin       string
	Counter            uint64
}

// PVZOrderCacheMockGetOrdersParams contains parameters of the PVZOrderCache.GetOrders
type PVZOrderCacheMockGetOrdersParams struct {
	ctx     context.Context
	userID  string
	options []abstractions.GetOrdersOptFunc
}

// PVZOrderCacheMockGetOrdersParamPtrs contains pointers to parameters of the PVZOrderCache.GetOrders
type PVZOrderCacheMockGetOrdersParamPtrs struct {
	ctx     *context.Context
	userID  *string
	options *[]abstractions.GetOrdersOptFunc
}

// PVZOrderCacheMockGetOrdersResults contains results of the PVZOrderCache.GetOrders
type PVZOrderCacheMockGetOrdersResults struct {
	pa1 []domain.PVZOrder
	e1  error
	b1  bool
}

// PVZOrderCacheMockGetOrdersOrigins contains origins of expectations of the PVZOrderCache.GetOrders
type PVZOrderCacheMockGetOrdersExpectationOrigins struct {
	origin        string
	originCtx     string
	originUserID  string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrders *mPVZOrderCacheMockGetOrders) Optional() *mPVZOrderCacheMockGetOrders {
	mmGetOrders.optional = true
	return mmGetOrders
}

// Expect sets up expected params for PVZOrderCache.GetOrders
func (mmGetOrders *mPVZOrderCacheMockGetOrders) Expect(ctx context.Context, userID string, options ...abstractions.GetOrdersOptFunc) *mPVZOrderCacheMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderCacheMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &PVZOrderCacheMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.paramPtrs != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderCacheMock.GetOrders mock is already set by ExpectParams functions")
	}

	mmGetOrders.defaultExpectation.params = &PVZOrderCacheMockGetOrdersParams{ctx, userID, options}
	mmGetOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrders.expectations {
		if minimock.Equal(e.params, mmGetOrders.defaultExpectation.params) {
			mmGetOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrders.defaultExpectation.params)
		}
	}

	return mmGetOrders
}

// ExpectCtxParam1 sets up expected param ctx for PVZOrderCache.GetOrders
func (mmGetOrders *mPVZOrderCacheMockGetOrders) ExpectCtxParam1(ctx context.Context) *mPVZOrderCacheMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderCacheMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &PVZOrderCacheMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderCacheMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &PVZOrderCacheMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrders
}

// ExpectUserIDParam2 sets up expected param userID for PVZOrderCache.GetOrders
func (mmGetOrders *mPVZOrderCacheMockGetOrders) ExpectUserIDParam2(userID string) *mPVZOrderCacheMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderCacheMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &PVZOrderCacheMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderCacheMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &PVZOrderCacheMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.userID = &userID
	mmGetOrders.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetOrders
}

// ExpectOptionsParam3 sets up expected param options for PVZOrderCache.GetOrders
func (mmGetOrders *mPVZOrderCacheMockGetOrders) ExpectOptionsParam3(options ...abstractions.GetOrdersOptFunc) *mPVZOrderCacheMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderCacheMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &PVZOrderCacheMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderCacheMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &PVZOrderCacheMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.options = &options
	mmGetOrders.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmGetOrders
}

// Inspect accepts an inspector function that has same arguments as the PVZOrderCache.GetOrders
func (mmGetOrders *mPVZOrderCacheMockGetOrders) Inspect(f func(ctx context.Context, userID string, options ...abstractions.GetOrdersOptFunc)) *mPVZOrderCacheMockGetOrders {
	if mmGetOrders.mock.inspectFuncGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("Inspect function is already set for PVZOrderCacheMock.GetOrders")
	}

	mmGetOrders.mock.inspectFuncGetOrders = f

	return mmGetOrders
}

// Return sets up results that will be returned by PVZOrderCache.GetOrders
func (mmGetOrders *mPVZOrderCacheMockGetOrders) Return(pa1 []domain.PVZOrder, e1 error, b1 bool) *PVZOrderCacheMock {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderCacheMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &PVZOrderCacheMockGetOrdersExpectation{mock: mmGetOrders.mock}
	}
	mmGetOrders.defaultExpectation.results = &PVZOrderCacheMockGetOrdersResults{pa1, e1, b1}
	mmGetOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrders.mock
}

// Set uses given function f to mock the PVZOrderCache.GetOrders method
func (mmGetOrders *mPVZOrderCacheMockGetOrders) Set(f func(ctx context.Context, userID string, options ...abstractions.GetOrdersOptFunc) (pa1 []domain.PVZOrder, e1 error, b1 bool)) *PVZOrderCacheMock {
	if mmGetOrders.defaultExpectation != nil {
		mmGetOrders.mock.t.Fatalf("Default expectation is already set for the PVZOrderCache.GetOrders method")
	}

	if len(mmGetOrders.expectations) > 0 {
		mmGetOrders.mock.t.Fatalf("Some expectations are already set for the PVZOrderCache.GetOrders method")
	}

	mmGetOrders.mock.funcGetOrders = f
	mmGetOrders.mock.funcGetOrdersOrigin = minimock.CallerInfo(1)
	return mmGetOrders.mock
}

// When sets expectation for the PVZOrderCache.GetOrders which will trigger the result defined by the following
// Then helper
func (mmGetOrders *mPVZOrderCacheMockGetOrders) When(ctx context.Context, userID string, options ...abstractions.GetOrdersOptFunc) *PVZOrderCacheMockGetOrdersExpectation {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("PVZOrderCacheMock.GetOrders mock is already set by Set")
	}

	expectation := &PVZOrderCacheMockGetOrdersExpectation{
		mock:               mmGetOrders.mock,
		params:             &PVZOrderCacheMockGetOrdersParams{ctx, userID, options},
		expectationOrigins: PVZOrderCacheMockGetOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrders.expectations = append(mmGetOrders.expectations, expectation)
	return expectation
}

// Then sets up PVZOrderCache.GetOrders return parameters for the expectation previously defined by the When method
func (e *PVZOrderCacheMockGetOrdersExpectation) Then(pa1 []domain.PVZOrder, e1 error, b1 bool) *PVZOrderCacheMock {
	e.results = &PVZOrderCacheMockGetOrdersResults{pa1, e1, b1}
	return e.mock
}

// Times sets number of times PVZOrderCache.GetOrders should be invoked
func (mmGetOrders *mPVZOrderCacheMockGetOrders) Times(n uint64) *mPVZOrderCacheMockGetOrders {
	if n == 0 {
		mmGetOrders.mock.t.Fatalf("Times of PVZOrderCacheMock.GetOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrders.expectedInvocations, n)
	mmGetOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrders
}

func (mmGetOrders *mPVZOrderCacheMockGetOrders) invocationsDone() bool {
	if len(mmGetOrders.expectations) == 0 && mmGetOrders.defaultExpectation == nil && mmGetOrders.mock.funcGetOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrders.mock.afterGetOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrders implements mm_usecases.PVZOrderCache
func (mmGetOrders *PVZOrderCacheMock) GetOrders(ctx context.Context, userID string, options ...abstractions.GetOrdersOptFunc) (pa1 []domain.PVZOrder, e1 error, b1 bool) {
	mm_atomic.AddUint64(&mmGetOrders.beforeGetOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrders.afterGetOrdersCounter, 1)

	mmGetOrders.t.Helper()

	if mmGetOrders.inspectFuncGetOrders != nil {
		mmGetOrders.inspectFuncGetOrders(ctx, userID, options...)
	}

	mm_params := PVZOrderCacheMockGetOrdersParams{ctx, userID, options}

	// Record call args
	mmGetOrders.GetOrdersMock.mutex.Lock()
	mmGetOrders.GetOrdersMock.callArgs = append(mmGetOrders.GetOrdersMock.callArgs, &mm_params)
	mmGetOrders.GetOrdersMock.mutex.Unlock()

	for _, e := range mmGetOrders.GetOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.e1, e.results.b1
		}
	}

	if mmGetOrders.GetOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrders.GetOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrders.GetOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrders.GetOrdersMock.defaultExpectation.paramPtrs

		mm_got := PVZOrderCacheMockGetOrdersParams{ctx, userID, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrders.t.Errorf("PVZOrderCacheMock.GetOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetOrders.t.Errorf("PVZOrderCacheMock.GetOrders got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmGetOrders.t.Errorf("PVZOrderCacheMock.GetOrders got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrders.t.Errorf("PVZOrderCacheMock.GetOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrders.GetOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrders.t.Fatal("No results are set for the PVZOrderCacheMock.GetOrders")
		}
		return (*mm_results).pa1, (*mm_results).e1, (*mm_results).b1
	}
	if mmGetOrders.funcGetOrders != nil {
		return mmGetOrders.funcGetOrders(ctx, userID, options...)
	}
	mmGetOrders.t.Fatalf("Unexpected call to PVZOrderCacheMock.GetOrders. %v %v %v", ctx, userID, options)
	return
}

// GetOrdersAfterCounter returns a count of finished PVZOrderCacheMock.GetOrders invocations
func (mmGetOrders *PVZOrderCacheMock) GetOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrders.afterGetOrdersCounter)
}

// GetOrdersBeforeCounter returns a count of PVZOrderCacheMock.GetOrders invocations
func (mmGetOrders *PVZOrderCacheMock) GetOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrders.beforeGetOrdersCounter)
}

// Calls returns a list of arguments used in each call to PVZOrderCacheMock.GetOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrders *mPVZOrderCacheMockGetOrders) Calls() []*PVZOrderCacheMockGetOrdersParams {
	mmGetOrders.mutex.RLock()

	argCopy := make([]*PVZOrderCacheMockGetOrdersParams, len(mmGetOrders.callArgs))
	copy(argCopy, mmGetOrders.callArgs)

	mmGetOrders.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrdersDone returns true if the count of the GetOrders invocations corresponds
// the number of defined expectations
func (m *PVZOrderCacheMock) MinimockGetOrdersDone() bool {
	if m.GetOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrdersMock.invocationsDone()
}

// MinimockGetOrdersInspect logs each unmet expectation
func (m *PVZOrderCacheMock) MinimockGetOrdersInspect() {
	for _, e := range m.GetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZOrderCacheMock.GetOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrdersCounter := mm_atomic.LoadUint64(&m.afterGetOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrdersMock.defaultExpectation != nil && afterGetOrdersCounter < 1 {
		if m.GetOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZOrderCacheMock.GetOrders at\n%s", m.GetOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZOrderCacheMock.GetOrders at\n%s with params: %#v", m.GetOrdersMock.defaultExpectation.expectationOrigins.origin, *m.GetOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrders != nil && afterGetOrdersCounter < 1 {
		m.t.Errorf("Expected call to PVZOrderCacheMock.GetOrders at\n%s", m.funcGetOrdersOrigin)
	}

	if !m.GetOrdersMock.invocationsDone() && afterGetOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZOrderCacheMock.GetOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrdersMock.expectedInvocations), m.GetOrdersMock.expectedInvocationsOrigin, afterGetOrdersCounter)
	}
}

type mPVZOrderCacheMockGetReturns struct {
	optional           bool
	mock               *PVZOrderCacheMock
	defaultExpectation *PVZOrderCacheMockGetReturnsExpectation
	expectations       []*PVZOrderCacheMockGetReturnsExpectation

	callArgs []*PVZOrderCacheMockGetReturnsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZOrderCacheMockGetReturnsExpectation specifies expectation struct of the PVZOrderCache.GetReturns
type PVZOrderCacheMockGetReturnsExpectation struct {
	mock               *PVZOrderCacheMock
	params             *PVZOrderCacheMockGetReturnsParams
	paramPtrs          *PVZOrderCacheMockGetReturnsParamPtrs
	expectationOrigins PVZOrderCacheMockGetReturnsExpectationOrigins
	results            *PVZOrderCacheMockGetReturnsResults
	returnOrigin       string
	Counter            uint64
}

// PVZOrderCacheMockGetReturnsParams contains parameters of the PVZOrderCache.GetReturns
type PVZOrderCacheMockGetReturnsParams struct {
	ctx     context.Context
	options []abstractions.PagePaginationOptFunc
}

// PVZOrderCacheMockGetReturnsParamPtrs contains pointers to parameters of the PVZOrderCache.GetReturns
type PVZOrderCacheMockGetReturnsParamPtrs struct {
	ctx     *context.Context
	options *[]abstractions.PagePaginationOptFunc
}

// PVZOrderCacheMockGetReturnsResults contains results of the PVZOrderCache.GetReturns
type PVZOrderCacheMockGetReturnsResults struct {
	pa1 []domain.PVZOrder
	e1  error
	b1  bool
}

// PVZOrderCacheMockGetReturnsOrigins contains origins of expectations of the PVZOrderCache.GetReturns
type PVZOrderCacheMockGetReturnsExpectationOrigins struct {
	origin        string
	originCtx     string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReturns *mPVZOrderCacheMockGetReturns) Optional() *mPVZOrderCacheMockGetReturns {
	mmGetReturns.optional = true
	return mmGetReturns
}

// Expect sets up expected params for PVZOrderCache.GetReturns
func (mmGetReturns *mPVZOrderCacheMockGetReturns) Expect(ctx context.Context, options ...abstractions.PagePaginationOptFunc) *mPVZOrderCacheMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderCacheMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &PVZOrderCacheMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.paramPtrs != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderCacheMock.GetReturns mock is already set by ExpectParams functions")
	}

	mmGetReturns.defaultExpectation.params = &PVZOrderCacheMockGetReturnsParams{ctx, options}
	mmGetReturns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReturns.expectations {
		if minimock.Equal(e.params, mmGetReturns.defaultExpectation.params) {
			mmGetReturns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReturns.defaultExpectation.params)
		}
	}

	return mmGetReturns
}

// ExpectCtxParam1 sets up expected param ctx for PVZOrderCache.GetReturns
func (mmGetReturns *mPVZOrderCacheMockGetReturns) ExpectCtxParam1(ctx context.Context) *mPVZOrderCacheMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderCacheMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &PVZOrderCacheMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.params != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderCacheMock.GetReturns mock is already set by Expect")
	}

	if mmGetReturns.defaultExpectation.paramPtrs == nil {
		mmGetReturns.defaultExpectation.paramPtrs = &PVZOrderCacheMockGetReturnsParamPtrs{}
	}
	mmGetReturns.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetReturns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetReturns
}

// ExpectOptionsParam2 sets up expected param options for PVZOrderCache.GetReturns
func (mmGetReturns *mPVZOrderCacheMockGetReturns) ExpectOptionsParam2(options ...abstractions.PagePaginationOptFunc) *mPVZOrderCacheMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderCacheMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &PVZOrderCacheMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.params != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderCacheMock.GetReturns mock is already set by Expect")
	}

	if mmGetReturns.defaultExpectation.paramPtrs == nil {
		mmGetReturns.defaultExpectation.paramPtrs = &PVZOrderCacheMockGetReturnsParamPtrs{}
	}
	mmGetReturns.defaultExpectation.paramPtrs.options = &options
	mmGetReturns.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmGetReturns
}

// Inspect accepts an inspector function that has same arguments as the PVZOrderCache.GetReturns
func (mmGetReturns *mPVZOrderCacheMockGetReturns) Inspect(f func(ctx context.Context, options ...abstractions.PagePaginationOptFunc)) *mPVZOrderCacheMockGetReturns {
	if mmGetReturns.mock.inspectFuncGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("Inspect function is already set for PVZOrderCacheMock.GetReturns")
	}

	mmGetReturns.mock.inspectFuncGetReturns = f

	return mmGetReturns
}

// Return sets up results that will be returned by PVZOrderCache.GetReturns
func (mmGetReturns *mPVZOrderCacheMockGetReturns) Return(pa1 []domain.PVZOrder, e1 error, b1 bool) *PVZOrderCacheMock {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderCacheMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &PVZOrderCacheMockGetReturnsExpectation{mock: mmGetReturns.mock}
	}
	mmGetReturns.defaultExpectation.results = &PVZOrderCacheMockGetReturnsResults{pa1, e1, b1}
	mmGetReturns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReturns.mock
}

// Set uses given function f to mock the PVZOrderCache.GetReturns method
func (mmGetReturns *mPVZOrderCacheMockGetReturns) Set(f func(ctx context.Context, options ...abstractions.PagePaginationOptFunc) (pa1 []domain.PVZOrder, e1 error, b1 bool)) *PVZOrderCacheMock {
	if mmGetReturns.defaultExpectation != nil {
		mmGetReturns.mock.t.Fatalf("Default expectation is already set for the PVZOrderCache.GetReturns method")
	}

	if len(mmGetReturns.expectations) > 0 {
		mmGetReturns.mock.t.Fatalf("Some expectations are already set for the PVZOrderCache.GetReturns method")
	}

	mmGetReturns.mock.funcGetReturns = f
	mmGetReturns.mock.funcGetReturnsOrigin = minimock.CallerInfo(1)
	return mmGetReturns.mock
}

// When sets expectation for the PVZOrderCache.GetReturns which will trigger the result defined by the following
// Then helper
func (mmGetReturns *mPVZOrderCacheMockGetReturns) When(ctx context.Context, options ...abstractions.PagePaginationOptFunc) *PVZOrderCacheMockGetReturnsExpectation {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("PVZOrderCacheMock.GetReturns mock is already set by Set")
	}

	expectation := &PVZOrderCacheMockGetReturnsExpectation{
		mock:               mmGetReturns.mock,
		params:             &PVZOrderCacheMockGetReturnsParams{ctx, options},
		expectationOrigins: PVZOrderCacheMockGetReturnsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReturns.expectations = append(mmGetReturns.expectations, expectation)
	return expectation
}

// Then sets up PVZOrderCache.GetReturns return parameters for the expectation previously defined by the When method
func (e *PVZOrderCacheMockGetReturnsExpectation) Then(pa1 []domain.PVZOrder, e1 error, b1 bool) *PVZOrderCacheMock {
	e.results = &PVZOrderCacheMockGetReturnsResults{pa1, e1, b1}
	return e.mock
}

// Times sets number of times PVZOrderCache.GetReturns should be invoked
func (mmGetReturns *mPVZOrderCacheMockGetReturns) Times(n uint64) *mPVZOrderCacheMockGetReturns {
	if n == 0 {
		mmGetReturns.mock.t.Fatalf("Times of PVZOrderCacheMock.GetReturns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReturns.expectedInvocations, n)
	mmGetReturns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReturns
}

func (mmGetReturns *mPVZOrderCacheMockGetReturns) invocationsDone() bool {
	if len(mmGetReturns.expectations) == 0 && mmGetReturns.defaultExpectation == nil && mmGetReturns.mock.funcGetReturns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReturns.mock.afterGetReturnsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReturns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReturns implements mm_usecases.PVZOrderCache
func (mmGetReturns *PVZOrderCacheMock) GetReturns(ctx context.Context, options ...abstractions.PagePaginationOptFunc) (pa1 []domain.PVZOrder, e1 error, b1 bool) {
	mm_atomic.AddUint64(&mmGetReturns.beforeGetReturnsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReturns.afterGetReturnsCounter, 1)

	mmGetReturns.t.Helper()

	if mmGetReturns.inspectFuncGetReturns != nil {
		mmGetReturns.inspectFuncGetReturns(ctx, options...)
	}

	mm_params := PVZOrderCacheMockGetReturnsParams{ctx, options}

	// Record call args
	mmGetReturns.GetReturnsMock.mutex.Lock()
	mmGetReturns.GetReturnsMock.callArgs = append(mmGetReturns.GetReturnsMock.callArgs, &mm_params)
	mmGetReturns.GetReturnsMock.mutex.Unlock()

	for _, e := range mmGetReturns.GetReturnsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.e1, e.results.b1
		}
	}

	if mmGetReturns.GetReturnsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReturns.GetReturnsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReturns.GetReturnsMock.defaultExpectation.params
		mm_want_ptrs := mmGetReturns.GetReturnsMock.defaultExpectation.paramPtrs

		mm_got := PVZOrderCacheMockGetReturnsParams{ctx, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetReturns.t.Errorf("PVZOrderCacheMock.GetReturns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmGetReturns.t.Errorf("PVZOrderCacheMock.GetReturns got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReturns.t.Errorf("PVZOrderCacheMock.GetReturns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReturns.GetReturnsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReturns.t.Fatal("No results are set for the PVZOrderCacheMock.GetReturns")
		}
		return (*mm_results).pa1, (*mm_results).e1, (*mm_results).b1
	}
	if mmGetReturns.funcGetReturns != nil {
		return mmGetReturns.funcGetReturns(ctx, options...)
	}
	mmGetReturns.t.Fatalf("Unexpected call to PVZOrderCacheMock.GetReturns. %v %v", ctx, options)
	return
}

// GetReturnsAfterCounter returns a count of finished PVZOrderCacheMock.GetReturns invocations
func (mmGetReturns *PVZOrderCacheMock) GetReturnsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturns.afterGetReturnsCounter)
}

// GetReturnsBeforeCounter returns a count of PVZOrderCacheMock.GetReturns invocations
func (mmGetReturns *PVZOrderCacheMock) GetReturnsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturns.beforeGetReturnsCounter)
}

// Calls returns a list of arguments used in each call to PVZOrderCacheMock.GetReturns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReturns *mPVZOrderCacheMockGetReturns) Calls() []*PVZOrderCacheMockGetReturnsParams {
	mmGetReturns.mutex.RLock()

	argCopy := make([]*PVZOrderCacheMockGetReturnsParams, len(mmGetReturns.callArgs))
	copy(argCopy, mmGetReturns.callArgs)

	mmGetReturns.mutex.RUnlock()

	return argCopy
}

// MinimockGetReturnsDone returns true if the count of the GetReturns invocations corresponds
// the number of defined expectations
func (m *PVZOrderCacheMock) MinimockGetReturnsDone() bool {
	if m.GetReturnsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReturnsMock.invocationsDone()
}

// MinimockGetReturnsInspect logs each unmet expectation
func (m *PVZOrderCacheMock) MinimockGetReturnsInspect() {
	for _, e := range m.GetReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZOrderCacheMock.GetReturns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReturnsCounter := mm_atomic.LoadUint64(&m.afterGetReturnsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReturnsMock.defaultExpectation != nil && afterGetReturnsCounter < 1 {
		if m.GetReturnsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZOrderCacheMock.GetReturns at\n%s", m.GetReturnsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZOrderCacheMock.GetReturns at\n%s with params: %#v", m.GetReturnsMock.defaultExpectation.expectationOrigins.origin, *m.GetReturnsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReturns != nil && afterGetReturnsCounter < 1 {
		m.t.Errorf("Expected call to PVZOrderCacheMock.GetReturns at\n%s", m.funcGetReturnsOrigin)
	}

	if !m.GetReturnsMock.invocationsDone() && afterGetReturnsCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZOrderCacheMock.GetReturns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReturnsMock.expectedInvocations), m.GetReturnsMock.expectedInvocationsOrigin, afterGetReturnsCounter)
	}
}

type mPVZOrderCacheMockSetGetOrders struct {
	optional           bool
	mock               *PVZOrderCacheMock
	defaultExpectation *PVZOrderCacheMockSetGetOrdersExpectation
	expectations       []*PVZOrderCacheMockSetGetOrdersExpectation

	callArgs []*PVZOrderCacheMockSetGetOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZOrderCacheMockSetGetOrdersExpectation specifies expectation struct of the PVZOrderCache.SetGetOrders
type PVZOrderCacheMockSetGetOrdersExpectation struct {
	mock               *PVZOrderCacheMock
	params             *PVZOrderCacheMockSetGetOrdersParams
	paramPtrs          *PVZOrderCacheMockSetGetOrdersParamPtrs
	expectationOrigins PVZOrderCacheMockSetGetOrdersExpectationOrigins
	results            *PVZOrderCacheMockSetGetOrdersResults
	returnOrigin       string
	Counter            uint64
}

// PVZOrderCacheMockSetGetOrdersParams contains parameters of the PVZOrderCache.SetGetOrders
type PVZOrderCacheMockSetGetOrdersParams struct {
	ctx     context.Context
	userID  string
	orders  []domain.PVZOrder
	options []abstractions.GetOrdersOptFunc
}

// PVZOrderCacheMockSetGetOrdersParamPtrs contains pointers to parameters of the PVZOrderCache.SetGetOrders
type PVZOrderCacheMockSetGetOrdersParamPtrs struct {
	ctx     *context.Context
	userID  *string
	orders  *[]domain.PVZOrder
	options *[]abstractions.GetOrdersOptFunc
}

// PVZOrderCacheMockSetGetOrdersResults contains results of the PVZOrderCache.SetGetOrders
type PVZOrderCacheMockSetGetOrdersResults struct {
	err error
}

// PVZOrderCacheMockSetGetOrdersOrigins contains origins of expectations of the PVZOrderCache.SetGetOrders
type PVZOrderCacheMockSetGetOrdersExpectationOrigins struct {
	origin        string
	originCtx     string
	originUserID  string
	originOrders  string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetGetOrders *mPVZOrderCacheMockSetGetOrders) Optional() *mPVZOrderCacheMockSetGetOrders {
	mmSetGetOrders.optional = true
	return mmSetGetOrders
}

// Expect sets up expected params for PVZOrderCache.SetGetOrders
func (mmSetGetOrders *mPVZOrderCacheMockSetGetOrders) Expect(ctx context.Context, userID string, orders []domain.PVZOrder, options ...abstractions.GetOrdersOptFunc) *mPVZOrderCacheMockSetGetOrders {
	if mmSetGetOrders.mock.funcSetGetOrders != nil {
		mmSetGetOrders.mock.t.Fatalf("PVZOrderCacheMock.SetGetOrders mock is already set by Set")
	}

	if mmSetGetOrders.defaultExpectation == nil {
		mmSetGetOrders.defaultExpectation = &PVZOrderCacheMockSetGetOrdersExpectation{}
	}

	if mmSetGetOrders.defaultExpectation.paramPtrs != nil {
		mmSetGetOrders.mock.t.Fatalf("PVZOrderCacheMock.SetGetOrders mock is already set by ExpectParams functions")
	}

	mmSetGetOrders.defaultExpectation.params = &PVZOrderCacheMockSetGetOrdersParams{ctx, userID, orders, options}
	mmSetGetOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetGetOrders.expectations {
		if minimock.Equal(e.params, mmSetGetOrders.defaultExpectation.params) {
			mmSetGetOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetGetOrders.defaultExpectation.params)
		}
	}

	return mmSetGetOrders
}

// ExpectCtxParam1 sets up expected param ctx for PVZOrderCache.SetGetOrders
func (mmSetGetOrders *mPVZOrderCacheMockSetGetOrders) ExpectCtxParam1(ctx context.Context) *mPVZOrderCacheMockSetGetOrders {
	if mmSetGetOrders.mock.funcSetGetOrders != nil {
		mmSetGetOrders.mock.t.Fatalf("PVZOrderCacheMock.SetGetOrders mock is already set by Set")
	}

	if mmSetGetOrders.defaultExpectation == nil {
		mmSetGetOrders.defaultExpectation = &PVZOrderCacheMockSetGetOrdersExpectation{}
	}

	if mmSetGetOrders.defaultExpectation.params != nil {
		mmSetGetOrders.mock.t.Fatalf("PVZOrderCacheMock.SetGetOrders mock is already set by Expect")
	}

	if mmSetGetOrders.defaultExpectation.paramPtrs == nil {
		mmSetGetOrders.defaultExpectation.paramPtrs = &PVZOrderCacheMockSetGetOrdersParamPtrs{}
	}
	mmSetGetOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetGetOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetGetOrders
}

// ExpectUserIDParam2 sets up expected param userID for PVZOrderCache.SetGetOrders
func (mmSetGetOrders *mPVZOrderCacheMockSetGetOrders) ExpectUserIDParam2(userID string) *mPVZOrderCacheMockSetGetOrders {
	if mmSetGetOrders.mock.funcSetGetOrders != nil {
		mmSetGetOrders.mock.t.Fatalf("PVZOrderCacheMock.SetGetOrders mock is already set by Set")
	}

	if mmSetGetOrders.defaultExpectation == nil {
		mmSetGetOrders.defaultExpectation = &PVZOrderCacheMockSetGetOrdersExpectation{}
	}

	if mmSetGetOrders.defaultExpectation.params != nil {
		mmSetGetOrders.mock.t.Fatalf("PVZOrderCacheMock.SetGetOrders mock is already set by Expect")
	}

	if mmSetGetOrders.defaultExpectation.paramPtrs == nil {
		mmSetGetOrders.defaultExpectation.paramPtrs = &PVZOrderCacheMockSetGetOrdersParamPtrs{}
	}
	mmSetGetOrders.defaultExpectation.paramPtrs.userID = &userID
	mmSetGetOrders.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmSetGetOrders
}

// ExpectOrdersParam3 sets up expected param orders for PVZOrderCache.SetGetOrders
func (mmSetGetOrders *mPVZOrderCacheMockSetGetOrders) ExpectOrdersParam3(orders []domain.PVZOrder) *mPVZOrderCacheMockSetGetOrders {
	if mmSetGetOrders.mock.funcSetGetOrders != nil {
		mmSetGetOrders.mock.t.Fatalf("PVZOrderCacheMock.SetGetOrders mock is already set by Set")
	}

	if mmSetGetOrders.defaultExpectation == nil {
		mmSetGetOrders.defaultExpectation = &PVZOrderCacheMockSetGetOrdersExpectation{}
	}

	if mmSetGetOrders.defaultExpectation.params != nil {
		mmSetGetOrders.mock.t.Fatalf("PVZOrderCacheMock.SetGetOrders mock is already set by Expect")
	}

	if mmSetGetOrders.defaultExpectation.paramPtrs == nil {
		mmSetGetOrders.defaultExpectation.paramPtrs = &PVZOrderCacheMockSetGetOrdersParamPtrs{}
	}
	mmSetGetOrders.defaultExpectation.paramPtrs.orders = &orders
	mmSetGetOrders.defaultExpectation.expectationOrigins.originOrders = minimock.CallerInfo(1)

	return mmSetGetOrders
}

// ExpectOptionsParam4 sets up expected param options for PVZOrderCache.SetGetOrders
func (mmSetGetOrders *mPVZOrderCacheMockSetGetOrders) ExpectOptionsParam4(options ...abstractions.GetOrdersOptFunc) *mPVZOrderCacheMockSetGetOrders {
	if mmSetGetOrders.mock.funcSetGetOrders != nil {
		mmSetGetOrders.mock.t.Fatalf("PVZOrderCacheMock.SetGetOrders mock is already set by Set")
	}

	if mmSetGetOrders.defaultExpectation == nil {
		mmSetGetOrders.defaultExpectation = &PVZOrderCacheMockSetGetOrdersExpectation{}
	}

	if mmSetGetOrders.defaultExpectation.params != nil {
		mmSetGetOrders.mock.t.Fatalf("PVZOrderCacheMock.SetGetOrders mock is already set by Expect")
	}

	if mmSetGetOrders.defaultExpectation.paramPtrs == nil {
		mmSetGetOrders.defaultExpectation.paramPtrs = &PVZOrderCacheMockSetGetOrdersParamPtrs{}
	}
	mmSetGetOrders.defaultExpectation.paramPtrs.options = &options
	mmSetGetOrders.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmSetGetOrders
}

// Inspect accepts an inspector function that has same arguments as the PVZOrderCache.SetGetOrders
func (mmSetGetOrders *mPVZOrderCacheMockSetGetOrders) Inspect(f func(ctx context.Context, userID string, orders []domain.PVZOrder, options ...abstractions.GetOrdersOptFunc)) *mPVZOrderCacheMockSetGetOrders {
	if mmSetGetOrders.mock.inspectFuncSetGetOrders != nil {
		mmSetGetOrders.mock.t.Fatalf("Inspect function is already set for PVZOrderCacheMock.SetGetOrders")
	}

	mmSetGetOrders.mock.inspectFuncSetGetOrders = f

	return mmSetGetOrders
}

// Return sets up results that will be returned by PVZOrderCache.SetGetOrders
func (mmSetGetOrders *mPVZOrderCacheMockSetGetOrders) Return(err error) *PVZOrderCacheMock {
	if mmSetGetOrders.mock.funcSetGetOrders != nil {
		mmSetGetOrders.mock.t.Fatalf("PVZOrderCacheMock.SetGetOrders mock is already set by Set")
	}

	if mmSetGetOrders.defaultExpectation == nil {
		mmSetGetOrders.defaultExpectation = &PVZOrderCacheMockSetGetOrdersExpectation{mock: mmSetGetOrders.mock}
	}
	mmSetGetOrders.defaultExpectation.results = &PVZOrderCacheMockSetGetOrdersResults{err}
	mmSetGetOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetGetOrders.mock
}

// Set uses given function f to mock the PVZOrderCache.SetGetOrders method
func (mmSetGetOrders *mPVZOrderCacheMockSetGetOrders) Set(f func(ctx context.Context, userID string, orders []domain.PVZOrder, options ...abstractions.GetOrdersOptFunc) (err error)) *PVZOrderCacheMock {
	if mmSetGetOrders.defaultExpectation != nil {
		mmSetGetOrders.mock.t.Fatalf("Default expectation is already set for the PVZOrderCache.SetGetOrders method")
	}

	if len(mmSetGetOrders.expectations) > 0 {
		mmSetGetOrders.mock.t.Fatalf("Some expectations are already set for the PVZOrderCache.SetGetOrders method")
	}

	mmSetGetOrders.mock.funcSetGetOrders = f
	mmSetGetOrders.mock.funcSetGetOrdersOrigin = minimock.CallerInfo(1)
	return mmSetGetOrders.mock
}

// When sets expectation for the PVZOrderCache.SetGetOrders which will trigger the result defined by the following
// Then helper
func (mmSetGetOrders *mPVZOrderCacheMockSetGetOrders) When(ctx context.Context, userID string, orders []domain.PVZOrder, options ...abstractions.GetOrdersOptFunc) *PVZOrderCacheMockSetGetOrdersExpectation {
	if mmSetGetOrders.mock.funcSetGetOrders != nil {
		mmSetGetOrders.mock.t.Fatalf("PVZOrderCacheMock.SetGetOrders mock is already set by Set")
	}

	expectation := &PVZOrderCacheMockSetGetOrdersExpectation{
		mock:               mmSetGetOrders.mock,
		params:             &PVZOrderCacheMockSetGetOrdersParams{ctx, userID, orders, options},
		expectationOrigins: PVZOrderCacheMockSetGetOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetGetOrders.expectations = append(mmSetGetOrders.expectations, expectation)
	return expectation
}

// Then sets up PVZOrderCache.SetGetOrders return parameters for the expectation previously defined by the When method
func (e *PVZOrderCacheMockSetGetOrdersExpectation) Then(err error) *PVZOrderCacheMock {
	e.results = &PVZOrderCacheMockSetGetOrdersResults{err}
	return e.mock
}

// Times sets number of times PVZOrderCache.SetGetOrders should be invoked
func (mmSetGetOrders *mPVZOrderCacheMockSetGetOrders) Times(n uint64) *mPVZOrderCacheMockSetGetOrders {
	if n == 0 {
		mmSetGetOrders.mock.t.Fatalf("Times of PVZOrderCacheMock.SetGetOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetGetOrders.expectedInvocations, n)
	mmSetGetOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetGetOrders
}

func (mmSetGetOrders *mPVZOrderCacheMockSetGetOrders) invocationsDone() bool {
	if len(mmSetGetOrders.expectations) == 0 && mmSetGetOrders.defaultExpectation == nil && mmSetGetOrders.mock.funcSetGetOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetGetOrders.mock.afterSetGetOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetGetOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetGetOrders implements mm_usecases.PVZOrderCache
func (mmSetGetOrders *PVZOrderCacheMock) SetGetOrders(ctx context.Context, userID string, orders []domain.PVZOrder, options ...abstractions.GetOrdersOptFunc) (err error) {
	mm_atomic.AddUint64(&mmSetGetOrders.beforeSetGetOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmSetGetOrders.afterSetGetOrdersCounter, 1)

	mmSetGetOrders.t.Helper()

	if mmSetGetOrders.inspectFuncSetGetOrders != nil {
		mmSetGetOrders.inspectFuncSetGetOrders(ctx, userID, orders, options...)
	}

	mm_params := PVZOrderCacheMockSetGetOrdersParams{ctx, userID, orders, options}

	// Record call args
	mmSetGetOrders.SetGetOrdersMock.mutex.Lock()
	mmSetGetOrders.SetGetOrdersMock.callArgs = append(mmSetGetOrders.SetGetOrdersMock.callArgs, &mm_params)
	mmSetGetOrders.SetGetOrdersMock.mutex.Unlock()

	for _, e := range mmSetGetOrders.SetGetOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetGetOrders.SetGetOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetGetOrders.SetGetOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmSetGetOrders.SetGetOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmSetGetOrders.SetGetOrdersMock.defaultExpectation.paramPtrs

		mm_got := PVZOrderCacheMockSetGetOrdersParams{ctx, userID, orders, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetGetOrders.t.Errorf("PVZOrderCacheMock.SetGetOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetGetOrders.SetGetOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmSetGetOrders.t.Errorf("PVZOrderCacheMock.SetGetOrders got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetGetOrders.SetGetOrdersMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.orders != nil && !minimock.Equal(*mm_want_ptrs.orders, mm_got.orders) {
				mmSetGetOrders.t.Errorf("PVZOrderCacheMock.SetGetOrders got unexpected parameter orders, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetGetOrders.SetGetOrdersMock.defaultExpectation.expectationOrigins.originOrders, *mm_want_ptrs.orders, mm_got.orders, minimock.Diff(*mm_want_ptrs.orders, mm_got.orders))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmSetGetOrders.t.Errorf("PVZOrderCacheMock.SetGetOrders got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetGetOrders.SetGetOrdersMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetGetOrders.t.Errorf("PVZOrderCacheMock.SetGetOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetGetOrders.SetGetOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetGetOrders.SetGetOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmSetGetOrders.t.Fatal("No results are set for the PVZOrderCacheMock.SetGetOrders")
		}
		return (*mm_results).err
	}
	if mmSetGetOrders.funcSetGetOrders != nil {
		return mmSetGetOrders.funcSetGetOrders(ctx, userID, orders, options...)
	}
	mmSetGetOrders.t.Fatalf("Unexpected call to PVZOrderCacheMock.SetGetOrders. %v %v %v %v", ctx, userID, orders, options)
	return
}

// SetGetOrdersAfterCounter returns a count of finished PVZOrderCacheMock.SetGetOrders invocations
func (mmSetGetOrders *PVZOrderCacheMock) SetGetOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetGetOrders.afterSetGetOrdersCounter)
}

// SetGetOrdersBeforeCounter returns a count of PVZOrderCacheMock.SetGetOrders invocations
func (mmSetGetOrders *PVZOrderCacheMock) SetGetOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetGetOrders.beforeSetGetOrdersCounter)
}

// Calls returns a list of arguments used in each call to PVZOrderCacheMock.SetGetOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetGetOrders *mPVZOrderCacheMockSetGetOrders) Calls() []*PVZOrderCacheMockSetGetOrdersParams {
	mmSetGetOrders.mutex.RLock()

	argCopy := make([]*PVZOrderCacheMockSetGetOrdersParams, len(mmSetGetOrders.callArgs))
	copy(argCopy, mmSetGetOrders.callArgs)

	mmSetGetOrders.mutex.RUnlock()

	return argCopy
}

// MinimockSetGetOrdersDone returns true if the count of the SetGetOrders invocations corresponds
// the number of defined expectations
func (m *PVZOrderCacheMock) MinimockSetGetOrdersDone() bool {
	if m.SetGetOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetGetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetGetOrdersMock.invocationsDone()
}

// MinimockSetGetOrdersInspect logs each unmet expectation
func (m *PVZOrderCacheMock) MinimockSetGetOrdersInspect() {
	for _, e := range m.SetGetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZOrderCacheMock.SetGetOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetGetOrdersCounter := mm_atomic.LoadUint64(&m.afterSetGetOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetGetOrdersMock.defaultExpectation != nil && afterSetGetOrdersCounter < 1 {
		if m.SetGetOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZOrderCacheMock.SetGetOrders at\n%s", m.SetGetOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZOrderCacheMock.SetGetOrders at\n%s with params: %#v", m.SetGetOrdersMock.defaultExpectation.expectationOrigins.origin, *m.SetGetOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetGetOrders != nil && afterSetGetOrdersCounter < 1 {
		m.t.Errorf("Expected call to PVZOrderCacheMock.SetGetOrders at\n%s", m.funcSetGetOrdersOrigin)
	}

	if !m.SetGetOrdersMock.invocationsDone() && afterSetGetOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZOrderCacheMock.SetGetOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetGetOrdersMock.expectedInvocations), m.SetGetOrdersMock.expectedInvocationsOrigin, afterSetGetOrdersCounter)
	}
}

type mPVZOrderCacheMockSetGetReturns struct {
	optional           bool
	mock               *PVZOrderCacheMock
	defaultExpectation *PVZOrderCacheMockSetGetReturnsExpectation
	expectations       []*PVZOrderCacheMockSetGetReturnsExpectation

	callArgs []*PVZOrderCacheMockSetGetReturnsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZOrderCacheMockSetGetReturnsExpectation specifies expectation struct of the PVZOrderCache.SetGetReturns
type PVZOrderCacheMockSetGetReturnsExpectation struct {
	mock               *PVZOrderCacheMock
	params             *PVZOrderCacheMockSetGetReturnsParams
	paramPtrs          *PVZOrderCacheMockSetGetReturnsParamPtrs
	expectationOrigins PVZOrderCacheMockSetGetReturnsExpectationOrigins
	results            *PVZOrderCacheMockSetGetReturnsResults
	returnOrigin       string
	Counter            uint64
}

// PVZOrderCacheMockSetGetReturnsParams contains parameters of the PVZOrderCache.SetGetReturns
type PVZOrderCacheMockSetGetReturnsParams struct {
	ctx     context.Context
	orders  []domain.PVZOrder
	options []abstractions.PagePaginationOptFunc
}

// PVZOrderCacheMockSetGetReturnsParamPtrs contains pointers to parameters of the PVZOrderCache.SetGetReturns
type PVZOrderCacheMockSetGetReturnsParamPtrs struct {
	ctx     *context.Context
	orders  *[]domain.PVZOrder
	options *[]abstractions.PagePaginationOptFunc
}

// PVZOrderCacheMockSetGetReturnsResults contains results of the PVZOrderCache.SetGetReturns
type PVZOrderCacheMockSetGetReturnsResults struct {
	err error
}

// PVZOrderCacheMockSetGetReturnsOrigins contains origins of expectations of the PVZOrderCache.SetGetReturns
type PVZOrderCacheMockSetGetReturnsExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrders  string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetGetReturns *mPVZOrderCacheMockSetGetReturns) Optional() *mPVZOrderCacheMockSetGetReturns {
	mmSetGetReturns.optional = true
	return mmSetGetReturns
}

// Expect sets up expected params for PVZOrderCache.SetGetReturns
func (mmSetGetReturns *mPVZOrderCacheMockSetGetReturns) Expect(ctx context.Context, orders []domain.PVZOrder, options ...abstractions.PagePaginationOptFunc) *mPVZOrderCacheMockSetGetReturns {
	if mmSetGetReturns.mock.funcSetGetReturns != nil {
		mmSetGetReturns.mock.t.Fatalf("PVZOrderCacheMock.SetGetReturns mock is already set by Set")
	}

	if mmSetGetReturns.defaultExpectation == nil {
		mmSetGetReturns.defaultExpectation = &PVZOrderCacheMockSetGetReturnsExpectation{}
	}

	if mmSetGetReturns.defaultExpectation.paramPtrs != nil {
		mmSetGetReturns.mock.t.Fatalf("PVZOrderCacheMock.SetGetReturns mock is already set by ExpectParams functions")
	}

	mmSetGetReturns.defaultExpectation.params = &PVZOrderCacheMockSetGetReturnsParams{ctx, orders, options}
	mmSetGetReturns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetGetReturns.expectations {
		if minimock.Equal(e.params, mmSetGetReturns.defaultExpectation.params) {
			mmSetGetReturns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetGetReturns.defaultExpectation.params)
		}
	}

	return mmSetGetReturns
}

// ExpectCtxParam1 sets up expected param ctx for PVZOrderCache.SetGetReturns
func (mmSetGetReturns *mPVZOrderCacheMockSetGetReturns) ExpectCtxParam1(ctx context.Context) *mPVZOrderCacheMockSetGetReturns {
	if mmSetGetReturns.mock.funcSetGetReturns != nil {
		mmSetGetReturns.mock.t.Fatalf("PVZOrderCacheMock.SetGetReturns mock is already set by Set")
	}

	if mmSetGetReturns.defaultExpectation == nil {
		mmSetGetReturns.defaultExpectation = &PVZOrderCacheMockSetGetReturnsExpectation{}
	}

	if mmSetGetReturns.defaultExpectation.params != nil {
		mmSetGetReturns.mock.t.Fatalf("PVZOrderCacheMock.SetGetReturns mock is already set by Expect")
	}

	if mmSetGetReturns.defaultExpectation.paramPtrs == nil {
		mmSetGetReturns.defaultExpectation.paramPtrs = &PVZOrderCacheMockSetGetReturnsParamPtrs{}
	}
	mmSetGetReturns.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetGetReturns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetGetReturns
}

// ExpectOrdersParam2 sets up expected param orders for PVZOrderCache.SetGetReturns
func (mmSetGetReturns *mPVZOrderCacheMockSetGetReturns) ExpectOrdersParam2(orders []domain.PVZOrder) *mPVZOrderCacheMockSetGetReturns {
	if mmSetGetReturns.mock.funcSetGetReturns != nil {
		mmSetGetReturns.mock.t.Fatalf("PVZOrderCacheMock.SetGetReturns mock is already set by Set")
	}

	if mmSetGetReturns.defaultExpectation == nil {
		mmSetGetReturns.defaultExpectation = &PVZOrderCacheMockSetGetReturnsExpectation{}
	}

	if mmSetGetReturns.defaultExpectation.params != nil {
		mmSetGetReturns.mock.t.Fatalf("PVZOrderCacheMock.SetGetReturns mock is already set by Expect")
	}

	if mmSetGetReturns.defaultExpectation.paramPtrs == nil {
		mmSetGetReturns.defaultExpectation.paramPtrs = &PVZOrderCacheMockSetGetReturnsParamPtrs{}
	}
	mmSetGetReturns.defaultExpectation.paramPtrs.orders = &orders
	mmSetGetReturns.defaultExpectation.expectationOrigins.originOrders = minimock.CallerInfo(1)

	return mmSetGetReturns
}

// ExpectOptionsParam3 sets up expected param options for PVZOrderCache.SetGetReturns
func (mmSetGetReturns *mPVZOrderCacheMockSetGetReturns) ExpectOptionsParam3(options ...abstractions.PagePaginationOptFunc) *mPVZOrderCacheMockSetGetReturns {
	if mmSetGetReturns.mock.funcSetGetReturns != nil {
		mmSetGetReturns.mock.t.Fatalf("PVZOrderCacheMock.SetGetReturns mock is already set by Set")
	}

	if mmSetGetReturns.defaultExpectation == nil {
		mmSetGetReturns.defaultExpectation = &PVZOrderCacheMockSetGetReturnsExpectation{}
	}

	if mmSetGetReturns.defaultExpectation.params != nil {
		mmSetGetReturns.mock.t.Fatalf("PVZOrderCacheMock.SetGetReturns mock is already set by Expect")
	}

	if mmSetGetReturns.defaultExpectation.paramPtrs == nil {
		mmSetGetReturns.defaultExpectation.paramPtrs = &PVZOrderCacheMockSetGetReturnsParamPtrs{}
	}
	mmSetGetReturns.defaultExpectation.paramPtrs.options = &options
	mmSetGetReturns.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmSetGetReturns
}

// Inspect accepts an inspector function that has same arguments as the PVZOrderCache.SetGetReturns
func (mmSetGetReturns *mPVZOrderCacheMockSetGetReturns) Inspect(f func(ctx context.Context, orders []domain.PVZOrder, options ...abstractions.PagePaginationOptFunc)) *mPVZOrderCacheMockSetGetReturns {
	if mmSetGetReturns.mock.inspectFuncSetGetReturns != nil {
		mmSetGetReturns.mock.t.Fatalf("Inspect function is already set for PVZOrderCacheMock.SetGetReturns")
	}

	mmSetGetReturns.mock.inspectFuncSetGetReturns = f

	return mmSetGetReturns
}

// Return sets up results that will be returned by PVZOrderCache.SetGetReturns
func (mmSetGetReturns *mPVZOrderCacheMockSetGetReturns) Return(err error) *PVZOrderCacheMock {
	if mmSetGetReturns.mock.funcSetGetReturns != nil {
		mmSetGetReturns.mock.t.Fatalf("PVZOrderCacheMock.SetGetReturns mock is already set by Set")
	}

	if mmSetGetReturns.defaultExpectation == nil {
		mmSetGetReturns.defaultExpectation = &PVZOrderCacheMockSetGetReturnsExpectation{mock: mmSetGetReturns.mock}
	}
	mmSetGetReturns.defaultExpectation.results = &PVZOrderCacheMockSetGetReturnsResults{err}
	mmSetGetReturns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetGetReturns.mock
}

// Set uses given function f to mock the PVZOrderCache.SetGetReturns method
func (mmSetGetReturns *mPVZOrderCacheMockSetGetReturns) Set(f func(ctx context.Context, orders []domain.PVZOrder, options ...abstractions.PagePaginationOptFunc) (err error)) *PVZOrderCacheMock {
	if mmSetGetReturns.defaultExpectation != nil {
		mmSetGetReturns.mock.t.Fatalf("Default expectation is already set for the PVZOrderCache.SetGetReturns method")
	}

	if len(mmSetGetReturns.expectations) > 0 {
		mmSetGetReturns.mock.t.Fatalf("Some expectations are already set for the PVZOrderCache.SetGetReturns method")
	}

	mmSetGetReturns.mock.funcSetGetReturns = f
	mmSetGetReturns.mock.funcSetGetReturnsOrigin = minimock.CallerInfo(1)
	return mmSetGetReturns.mock
}

// When sets expectation for the PVZOrderCache.SetGetReturns which will trigger the result defined by the following
// Then helper
func (mmSetGetReturns *mPVZOrderCacheMockSetGetReturns) When(ctx context.Context, orders []domain.PVZOrder, options ...abstractions.PagePaginationOptFunc) *PVZOrderCacheMockSetGetReturnsExpectation {
	if mmSetGetReturns.mock.funcSetGetReturns != nil {
		mmSetGetReturns.mock.t.Fatalf("PVZOrderCacheMock.SetGetReturns mock is already set by Set")
	}

	expectation := &PVZOrderCacheMockSetGetReturnsExpectation{
		mock:               mmSetGetReturns.mock,
		params:             &PVZOrderCacheMockSetGetReturnsParams{ctx, orders, options},
		expectationOrigins: PVZOrderCacheMockSetGetReturnsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetGetReturns.expectations = append(mmSetGetReturns.expectations, expectation)
	return expectation
}

// Then sets up PVZOrderCache.SetGetReturns return parameters for the expectation previously defined by the When method
func (e *PVZOrderCacheMockSetGetReturnsExpectation) Then(err error) *PVZOrderCacheMock {
	e.results = &PVZOrderCacheMockSetGetReturnsResults{err}
	return e.mock
}

// Times sets number of times PVZOrderCache.SetGetReturns should be invoked
func (mmSetGetReturns *mPVZOrderCacheMockSetGetReturns) Times(n uint64) *mPVZOrderCacheMockSetGetReturns {
	if n == 0 {
		mmSetGetReturns.mock.t.Fatalf("Times of PVZOrderCacheMock.SetGetReturns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetGetReturns.expectedInvocations, n)
	mmSetGetReturns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetGetReturns
}

func (mmSetGetReturns *mPVZOrderCacheMockSetGetReturns) invocationsDone() bool {
	if len(mmSetGetReturns.expectations) == 0 && mmSetGetReturns.defaultExpectation == nil && mmSetGetReturns.mock.funcSetGetReturns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetGetReturns.mock.afterSetGetReturnsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetGetReturns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetGetReturns implements mm_usecases.PVZOrderCache
func (mmSetGetReturns *PVZOrderCacheMock) SetGetReturns(ctx context.Context, orders []domain.PVZOrder, options ...abstractions.PagePaginationOptFunc) (err error) {
	mm_atomic.AddUint64(&mmSetGetReturns.beforeSetGetReturnsCounter, 1)
	defer mm_atomic.AddUint64(&mmSetGetReturns.afterSetGetReturnsCounter, 1)

	mmSetGetReturns.t.Helper()

	if mmSetGetReturns.inspectFuncSetGetReturns != nil {
		mmSetGetReturns.inspectFuncSetGetReturns(ctx, orders, options...)
	}

	mm_params := PVZOrderCacheMockSetGetReturnsParams{ctx, orders, options}

	// Record call args
	mmSetGetReturns.SetGetReturnsMock.mutex.Lock()
	mmSetGetReturns.SetGetReturnsMock.callArgs = append(mmSetGetReturns.SetGetReturnsMock.callArgs, &mm_params)
	mmSetGetReturns.SetGetReturnsMock.mutex.Unlock()

	for _, e := range mmSetGetReturns.SetGetReturnsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetGetReturns.SetGetReturnsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetGetReturns.SetGetReturnsMock.defaultExpectation.Counter, 1)
		mm_want := mmSetGetReturns.SetGetReturnsMock.defaultExpectation.params
		mm_want_ptrs := mmSetGetReturns.SetGetReturnsMock.defaultExpectation.paramPtrs

		mm_got := PVZOrderCacheMockSetGetReturnsParams{ctx, orders, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetGetReturns.t.Errorf("PVZOrderCacheMock.SetGetReturns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetGetReturns.SetGetReturnsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orders != nil && !minimock.Equal(*mm_want_ptrs.orders, mm_got.orders) {
				mmSetGetReturns.t.Errorf("PVZOrderCacheMock.SetGetReturns got unexpected parameter orders, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetGetReturns.SetGetReturnsMock.defaultExpectation.expectationOrigins.originOrders, *mm_want_ptrs.orders, mm_got.orders, minimock.Diff(*mm_want_ptrs.orders, mm_got.orders))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmSetGetReturns.t.Errorf("PVZOrderCacheMock.SetGetReturns got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetGetReturns.SetGetReturnsMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetGetReturns.t.Errorf("PVZOrderCacheMock.SetGetReturns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetGetReturns.SetGetReturnsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetGetReturns.SetGetReturnsMock.defaultExpectation.results
		if mm_results == nil {
			mmSetGetReturns.t.Fatal("No results are set for the PVZOrderCacheMock.SetGetReturns")
		}
		return (*mm_results).err
	}
	if mmSetGetReturns.funcSetGetReturns != nil {
		return mmSetGetReturns.funcSetGetReturns(ctx, orders, options...)
	}
	mmSetGetReturns.t.Fatalf("Unexpected call to PVZOrderCacheMock.SetGetReturns. %v %v %v", ctx, orders, options)
	return
}

// SetGetReturnsAfterCounter returns a count of finished PVZOrderCacheMock.SetGetReturns invocations
func (mmSetGetReturns *PVZOrderCacheMock) SetGetReturnsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetGetReturns.afterSetGetReturnsCounter)
}

// SetGetReturnsBeforeCounter returns a count of PVZOrderCacheMock.SetGetReturns invocations
func (mmSetGetReturns *PVZOrderCacheMock) SetGetReturnsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetGetReturns.beforeSetGetReturnsCounter)
}

// Calls returns a list of arguments used in each call to PVZOrderCacheMock.SetGetReturns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetGetReturns *mPVZOrderCacheMockSetGetReturns) Calls() []*PVZOrderCacheMockSetGetReturnsParams {
	mmSetGetReturns.mutex.RLock()

	argCopy := make([]*PVZOrderCacheMockSetGetReturnsParams, len(mmSetGetReturns.callArgs))
	copy(argCopy, mmSetGetReturns.callArgs)

	mmSetGetReturns.mutex.RUnlock()

	return argCopy
}

// MinimockSetGetReturnsDone returns true if the count of the SetGetReturns invocations corresponds
// the number of defined expectations
func (m *PVZOrderCacheMock) MinimockSetGetReturnsDone() bool {
	if m.SetGetReturnsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetGetReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetGetReturnsMock.invocationsDone()
}

// MinimockSetGetReturnsInspect logs each unmet expectation
func (m *PVZOrderCacheMock) MinimockSetGetReturnsInspect() {
	for _, e := range m.SetGetReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZOrderCacheMock.SetGetReturns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetGetReturnsCounter := mm_atomic.LoadUint64(&m.afterSetGetReturnsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetGetReturnsMock.defaultExpectation != nil && afterSetGetReturnsCounter < 1 {
		if m.SetGetReturnsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZOrderCacheMock.SetGetReturns at\n%s", m.SetGetReturnsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZOrderCacheMock.SetGetReturns at\n%s with params: %#v", m.SetGetReturnsMock.defaultExpectation.expectationOrigins.origin, *m.SetGetReturnsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetGetReturns != nil && afterSetGetReturnsCounter < 1 {
		m.t.Errorf("Expected call to PVZOrderCacheMock.SetGetReturns at\n%s", m.funcSetGetReturnsOrigin)
	}

	if !m.SetGetReturnsMock.invocationsDone() && afterSetGetReturnsCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZOrderCacheMock.SetGetReturns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetGetReturnsMock.expectedInvocations), m.SetGetReturnsMock.expectedInvocationsOrigin, afterSetGetReturnsCounter)
	}
}

type mPVZOrderCacheMockSetOrder struct {
	optional           bool
	mock               *PVZOrderCacheMock
	defaultExpectation *PVZOrderCacheMockSetOrderExpectation
	expectations       []*PVZOrderCacheMockSetOrderExpectation

	callArgs []*PVZOrderCacheMockSetOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZOrderCacheMockSetOrderExpectation specifies expectation struct of the PVZOrderCache.SetOrder
type PVZOrderCacheMockSetOrderExpectation struct {
	mock               *PVZOrderCacheMock
	params             *PVZOrderCacheMockSetOrderParams
	paramPtrs          *PVZOrderCacheMockSetOrderParamPtrs
	expectationOrigins PVZOrderCacheMockSetOrderExpectationOrigins
	results            *PVZOrderCacheMockSetOrderResults
	returnOrigin       string
	Counter            uint64
}

// PVZOrderCacheMockSetOrderParams contains parameters of the PVZOrderCache.SetOrder
type PVZOrderCacheMockSetOrderParams struct {
	ctx   context.Context
	order domain.PVZOrder
}

// PVZOrderCacheMockSetOrderParamPtrs contains pointers to parameters of the PVZOrderCache.SetOrder
type PVZOrderCacheMockSetOrderParamPtrs struct {
	ctx   *context.Context
	order *domain.PVZOrder
}

// PVZOrderCacheMockSetOrderResults contains results of the PVZOrderCache.SetOrder
type PVZOrderCacheMockSetOrderResults struct {
	err error
}

// PVZOrderCacheMockSetOrderOrigins contains origins of expectations of the PVZOrderCache.SetOrder
type PVZOrderCacheMockSetOrderExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetOrder *mPVZOrderCacheMockSetOrder) Optional() *mPVZOrderCacheMockSetOrder {
	mmSetOrder.optional = true
	return mmSetOrder
}

// Expect sets up expected params for PVZOrderCache.SetOrder
func (mmSetOrder *mPVZOrderCacheMockSetOrder) Expect(ctx context.Context, order domain.PVZOrder) *mPVZOrderCacheMockSetOrder {
	if mmSetOrder.mock.funcSetOrder != nil {
		mmSetOrder.mock.t.Fatalf("PVZOrderCacheMock.SetOrder mock is already set by Set")
	}

	if mmSetOrder.defaultExpectation == nil {
		mmSetOrder.defaultExpectation = &PVZOrderCacheMockSetOrderExpectation{}
	}

	if mmSetOrder.defaultExpectation.paramPtrs != nil {
		mmSetOrder.mock.t.Fatalf("PVZOrderCacheMock.SetOrder mock is already set by ExpectParams functions")
	}

	mmSetOrder.defaultExpectation.params = &PVZOrderCacheMockSetOrderParams{ctx, order}
	mmSetOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetOrder.expectations {
		if minimock.Equal(e.params, mmSetOrder.defaultExpectation.params) {
			mmSetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetOrder.defaultExpectation.params)
		}
	}

	return mmSetOrder
}

// ExpectCtxParam1 sets up expected param ctx for PVZOrderCache.SetOrder
func (mmSetOrder *mPVZOrderCacheMockSetOrder) ExpectCtxParam1(ctx context.Context) *mPVZOrderCacheMockSetOrder {
	if mmSetOrder.mock.funcSetOrder != nil {
		mmSetOrder.mock.t.Fatalf("PVZOrderCacheMock.SetOrder mock is already set by Set")
	}

	if mmSetOrder.defaultExpectation == nil {
		mmSetOrder.defaultExpectation = &PVZOrderCacheMockSetOrderExpectation{}
	}

	if mmSetOrder.defaultExpectation.params != nil {
		mmSetOrder.mock.t.Fatalf("PVZOrderCacheMock.SetOrder mock is already set by Expect")
	}

	if mmSetOrder.defaultExpectation.paramPtrs == nil {
		mmSetOrder.defaultExpectation.paramPtrs = &PVZOrderCacheMockSetOrderParamPtrs{}
	}
	mmSetOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetOrder
}

// ExpectOrderParam2 sets up expected param order for PVZOrderCache.SetOrder
func (mmSetOrder *mPVZOrderCacheMockSetOrder) ExpectOrderParam2(order domain.PVZOrder) *mPVZOrderCacheMockSetOrder {
	if mmSetOrder.mock.funcSetOrder != nil {
		mmSetOrder.mock.t.Fatalf("PVZOrderCacheMock.SetOrder mock is already set by Set")
	}

	if mmSetOrder.defaultExpectation == nil {
		mmSetOrder.defaultExpectation = &PVZOrderCacheMockSetOrderExpectation{}
	}

	if mmSetOrder.defaultExpectation.params != nil {
		mmSetOrder.mock.t.Fatalf("PVZOrderCacheMock.SetOrder mock is already set by Expect")
	}

	if mmSetOrder.defaultExpectation.paramPtrs == nil {
		mmSetOrder.defaultExpectation.paramPtrs = &PVZOrderCacheMockSetOrderParamPtrs{}
	}
	mmSetOrder.defaultExpectation.paramPtrs.order = &order
	mmSetOrder.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmSetOrder
}

// Inspect accepts an inspector function that has same arguments as the PVZOrderCache.SetOrder
func (mmSetOrder *mPVZOrderCacheMockSetOrder) Inspect(f func(ctx context.Context, order domain.PVZOrder)) *mPVZOrderCacheMockSetOrder {
	if mmSetOrder.mock.inspectFuncSetOrder != nil {
		mmSetOrder.mock.t.Fatalf("Inspect function is already set for PVZOrderCacheMock.SetOrder")
	}

	mmSetOrder.mock.inspectFuncSetOrder = f

	return mmSetOrder
}

// Return sets up results that will be returned by PVZOrderCache.SetOrder
func (mmSetOrder *mPVZOrderCacheMockSetOrder) Return(err error) *PVZOrderCacheMock {
	if mmSetOrder.mock.funcSetOrder != nil {
		mmSetOrder.mock.t.Fatalf("PVZOrderCacheMock.SetOrder mock is already set by Set")
	}

	if mmSetOrder.defaultExpectation == nil {
		mmSetOrder.defaultExpectation = &PVZOrderCacheMockSetOrderExpectation{mock: mmSetOrder.mock}
	}
	mmSetOrder.defaultExpectation.results = &PVZOrderCacheMockSetOrderResults{err}
	mmSetOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetOrder.mock
}

// Set uses given function f to mock the PVZOrderCache.SetOrder method
func (mmSetOrder *mPVZOrderCacheMockSetOrder) Set(f func(ctx context.Context, order domain.PVZOrder) (err error)) *PVZOrderCacheMock {
	if mmSetOrder.defaultExpectation != nil {
		mmSetOrder.mock.t.Fatalf("Default expectation is already set for the PVZOrderCache.SetOrder method")
	}

	if len(mmSetOrder.expectations) > 0 {
		mmSetOrder.mock.t.Fatalf("Some expectations are already set for the PVZOrderCache.SetOrder method")
	}

	mmSetOrder.mock.funcSetOrder = f
	mmSetOrder.mock.funcSetOrderOrigin = minimock.CallerInfo(1)
	return mmSetOrder.mock
}

// When sets expectation for the PVZOrderCache.SetOrder which will trigger the result defined by the following
// Then helper
func (mmSetOrder *mPVZOrderCacheMockSetOrder) When(ctx context.Context, order domain.PVZOrder) *PVZOrderCacheMockSetOrderExpectation {
	if mmSetOrder.mock.funcSetOrder != nil {
		mmSetOrder.mock.t.Fatalf("PVZOrderCacheMock.SetOrder mock is already set by Set")
	}

	expectation := &PVZOrderCacheMockSetOrderExpectation{
		mock:               mmSetOrder.mock,
		params:             &PVZOrderCacheMockSetOrderParams{ctx, order},
		expectationOrigins: PVZOrderCacheMockSetOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetOrder.expectations = append(mmSetOrder.expectations, expectation)
	return expectation
}

// Then sets up PVZOrderCache.SetOrder return parameters for the expectation previously defined by the When method
func (e *PVZOrderCacheMockSetOrderExpectation) Then(err error) *PVZOrderCacheMock {
	e.results = &PVZOrderCacheMockSetOrderResults{err}
	return e.mock
}

// Times sets number of times PVZOrderCache.SetOrder should be invoked
func (mmSetOrder *mPVZOrderCacheMockSetOrder) Times(n uint64) *mPVZOrderCacheMockSetOrder {
	if n == 0 {
		mmSetOrder.mock.t.Fatalf("Times of PVZOrderCacheMock.SetOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetOrder.expectedInvocations, n)
	mmSetOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetOrder
}

func (mmSetOrder *mPVZOrderCacheMockSetOrder) invocationsDone() bool {
	if len(mmSetOrder.expectations) == 0 && mmSetOrder.defaultExpectation == nil && mmSetOrder.mock.funcSetOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetOrder.mock.afterSetOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetOrder implements mm_usecases.PVZOrderCache
func (mmSetOrder *PVZOrderCacheMock) SetOrder(ctx context.Context, order domain.PVZOrder) (err error) {
	mm_atomic.AddUint64(&mmSetOrder.beforeSetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmSetOrder.afterSetOrderCounter, 1)

	mmSetOrder.t.Helper()

	if mmSetOrder.inspectFuncSetOrder != nil {
		mmSetOrder.inspectFuncSetOrder(ctx, order)
	}

	mm_params := PVZOrderCacheMockSetOrderParams{ctx, order}

	// Record call args
	mmSetOrder.SetOrderMock.mutex.Lock()
	mmSetOrder.SetOrderMock.callArgs = append(mmSetOrder.SetOrderMock.callArgs, &mm_params)
	mmSetOrder.SetOrderMock.mutex.Unlock()

	for _, e := range mmSetOrder.SetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetOrder.SetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetOrder.SetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmSetOrder.SetOrderMock.defaultExpectation.params
		mm_want_ptrs := mmSetOrder.SetOrderMock.defaultExpectation.paramPtrs

		mm_got := PVZOrderCacheMockSetOrderParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetOrder.t.Errorf("PVZOrderCacheMock.SetOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOrder.SetOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmSetOrder.t.Errorf("PVZOrderCacheMock.SetOrder got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOrder.SetOrderMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetOrder.t.Errorf("PVZOrderCacheMock.SetOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetOrder.SetOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetOrder.SetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmSetOrder.t.Fatal("No results are set for the PVZOrderCacheMock.SetOrder")
		}
		return (*mm_results).err
	}
	if mmSetOrder.funcSetOrder != nil {
		return mmSetOrder.funcSetOrder(ctx, order)
	}
	mmSetOrder.t.Fatalf("Unexpected call to PVZOrderCacheMock.SetOrder. %v %v", ctx, order)
	return
}

// SetOrderAfterCounter returns a count of finished PVZOrderCacheMock.SetOrder invocations
func (mmSetOrder *PVZOrderCacheMock) SetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOrder.afterSetOrderCounter)
}

// SetOrderBeforeCounter returns a count of PVZOrderCacheMock.SetOrder invocations
func (mmSetOrder *PVZOrderCacheMock) SetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOrder.beforeSetOrderCounter)
}

// Calls returns a list of arguments used in each call to PVZOrderCacheMock.SetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetOrder *mPVZOrderCacheMockSetOrder) Calls() []*PVZOrderCacheMockSetOrderParams {
	mmSetOrder.mutex.RLock()

	argCopy := make([]*PVZOrderCacheMockSetOrderParams, len(mmSetOrder.callArgs))
	copy(argCopy, mmSetOrder.callArgs)

	mmSetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockSetOrderDone returns true if the count of the SetOrder invocations corresponds
// the number of defined expectations
func (m *PVZOrderCacheMock) MinimockSetOrderDone() bool {
	if m.SetOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetOrderMock.invocationsDone()
}

// MinimockSetOrderInspect logs each unmet expectation
func (m *PVZOrderCacheMock) MinimockSetOrderInspect() {
	for _, e := range m.SetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZOrderCacheMock.SetOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetOrderCounter := mm_atomic.LoadUint64(&m.afterSetOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetOrderMock.defaultExpectation != nil && afterSetOrderCounter < 1 {
		if m.SetOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZOrderCacheMock.SetOrder at\n%s", m.SetOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZOrderCacheMock.SetOrder at\n%s with params: %#v", m.SetOrderMock.defaultExpectation.expectationOrigins.origin, *m.SetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetOrder != nil && afterSetOrderCounter < 1 {
		m.t.Errorf("Expected call to PVZOrderCacheMock.SetOrder at\n%s", m.funcSetOrderOrigin)
	}

	if !m.SetOrderMock.invocationsDone() && afterSetOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZOrderCacheMock.SetOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetOrderMock.expectedInvocations), m.SetOrderMock.expectedInvocationsOrigin, afterSetOrderCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PVZOrderCacheMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetOrderInspect()

			m.MinimockGetOrdersInspect()

			m.MinimockGetReturnsInspect()

			m.MinimockSetGetOrdersInspect()

			m.MinimockSetGetReturnsInspect()

			m.MinimockSetOrderInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PVZOrderCacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PVZOrderCacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetOrderDone() &&
		m.MinimockGetOrdersDone() &&
		m.MinimockGetReturnsDone() &&
		m.MinimockSetGetOrdersDone() &&
		m.MinimockSetGetReturnsDone() &&
		m.MinimockSetOrderDone()
}
